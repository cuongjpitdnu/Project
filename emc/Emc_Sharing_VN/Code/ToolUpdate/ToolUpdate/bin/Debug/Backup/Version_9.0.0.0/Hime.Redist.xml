<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Hime.Redist</name>
    </assembly>
    <members>
        <member name="T:Hime.Redist.AST">
            <summary>
            Represents a simple AST with a tree structure
            </summary>
            <remarks>
            The nodes are stored in sequential arrays where the children of a node are an inner sequence.
            The linkage is represented by each node storing its number of children and the index of its first child.
            </remarks>
        </member>
        <member name="T:Hime.Redist.AST.Node">
            <summary>
            Represents a node in this AST
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.Node.label">
            <summary>
            The node's label
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.Node.count">
            <summary>
            The number of children
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.Node.first">
            <summary>
            The index of the first child
            </summary>
        </member>
        <member name="M:Hime.Redist.AST.Node.#ctor(Hime.Redist.TableElemRef)">
            <summary>
            Initializes this node
            </summary>
            <param name="label">The node's label</param>
        </member>
        <member name="M:Hime.Redist.AST.Node.#ctor(Hime.Redist.TableElemRef,System.Int32,System.Int32)">
            <summary>
            Initializes this node
            </summary>
            <param name="label">The node's label</param>
            <param name="count">The number of children</param>
            <param name="first">The index of the first child</param>
        </member>
        <member name="T:Hime.Redist.AST.ChildEnumerator">
            <summary>
            Represents and iterator for adjacents in this graph
            </summary>
        </member>
        <member name="P:Hime.Redist.AST.ChildEnumerator.Current">
            <summary>
            Gets the current node
            </summary>
        </member>
        <member name="P:Hime.Redist.AST.ChildEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current node
            </summary>
        </member>
        <member name="M:Hime.Redist.AST.ChildEnumerator.Dispose">
            <summary>
            Disposes this enumerator
            </summary>
        </member>
        <member name="M:Hime.Redist.AST.ChildEnumerator.MoveNext">
            <summary>
            Moves to the next node
            </summary>
            <returns>true if there are more nodes</returns>
        </member>
        <member name="M:Hime.Redist.AST.ChildEnumerator.Reset">
            <summary>
            Resets this enumerator to the beginning
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.tableTokens">
            <summary>
            The table of tokens
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.tableVariables">
            <summary>
            The table of variables
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.tableVirtuals">
            <summary>
            The table of virtuals
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.nodes">
            <summary>
            The nodes' labels
            </summary>
        </member>
        <member name="F:Hime.Redist.AST.root">
            <summary>
            The index of the tree's root node
            </summary>
        </member>
        <member name="M:Hime.Redist.AST.#ctor(Hime.Redist.TokenRepository,Hime.Redist.Utils.ROList{Hime.Redist.Symbol},Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Initializes this AST
            </summary>
            <param name="tokens">The table of tokens</param>
            <param name="variables">The table of variables</param>
            <param name="virtuals">The table of virtuals</param>
        </member>
        <member name="P:Hime.Redist.AST.Root">
            <summary>
            Gets the root node of this tree
            </summary>
        </member>
        <member name="M:Hime.Redist.AST.GetChildrenCount(System.Int32)">
            <summary>
            Gets the number of children of the given node
            </summary>
            <param name="node">A node</param>
            <returns>The node's number of children</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetChild(System.Int32,System.Int32)">
            <summary>
            Gets the i-th child of the given node
            </summary>
            <param name="parent">A node</param>
            <param name="i">The child's number</param>
            <returns>The i-th child</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetChildren(System.Int32)">
            <summary>
            Gets an enumerator for the children of the given node
            </summary>
            <param name="parent">A node</param>
            <returns>An enumerator for the children</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSymbolType(System.Int32)">
            <summary>
            Gets the type of symbol for the given node
            </summary>
            <param name="node">A node</param>
            <returns>The type of symbol for the node</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetPosition(System.Int32)">
            <summary>
            Gets the position in the input text of the given node
            </summary>
            <param name="node">A node</param>
            <returns>The position in the text</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSpan(System.Int32)">
            <summary>
            Gets the span in the input text of the given node
            </summary>
            <param name="node">A node</param>
            <returns>The span in the text</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetContext(System.Int32)">
            <summary>
            Gets the context in the input of the given node
            </summary>
            <param name="node">A node</param>
            <returns>The context</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSymbol(System.Int32)">
            <summary>
            Gets the grammar symbol associated to the given node
            </summary>
            <param name="node">A node</param>
            <returns>The associated symbol</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetValue(System.Int32)">
            <summary>
            Gets the value of the given node
            </summary>
            <param name="node">A node</param>
            <returns>The associated value</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSymbolFor(Hime.Redist.TableElemRef)">
            <summary>
            Gets the symbol corresponding to the specified label
            </summary>
            <param name="label">A node label</param>
            <returns>The corresponding symbol</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSemanticElementForNode(System.Int32)">
            <summary>
            Gets the semantic element corresponding to the specified node
            </summary>
            <param name="node">A node</param>
            <returns>The corresponding semantic element</returns>
        </member>
        <member name="M:Hime.Redist.AST.GetSemanticElementForLabel(Hime.Redist.TableElemRef)">
            <summary>
            Gets the semantic element corresponding to the specified label
            </summary>
            <param name="label">The label of an AST node</param>
            <returns>The corresponding semantic element</returns>
        </member>
        <member name="M:Hime.Redist.AST.FindTokenAt(System.Int32)">
            <summary>
            Gets the token (if any) that contains the specified index in the input text
            </summary>
            <param name="index">An index within the input text</param>
            <returns>The token, if any</returns>
        </member>
        <member name="M:Hime.Redist.AST.FindNodeFor(Hime.Redist.Token)">
            <summary>
            Gets the AST node (if any) that has the specified token as label
            </summary>
            <param name="token">The token to look for</param>
            <returns>The AST node, if any</returns>
        </member>
        <member name="M:Hime.Redist.AST.FindParentOf(System.Int32)">
            <summary>
            Gets the parent of the specified node, if any
            </summary>
            <param name="node">A node</param>
            <returns>The parent node, if any</returns>
        </member>
        <member name="M:Hime.Redist.AST.Store(Hime.Redist.AST.Node[],System.Int32,System.Int32)">
            <summary>
            Stores some children nodes in this AST
            </summary>
            <param name="nodes">The nodes to store</param>
            <param name="index">The starting index of the nodes in the data to store</param>
            <param name="count">The number of nodes to store</param>
            <returns>The index of the first inserted node in this tree</returns>
        </member>
        <member name="M:Hime.Redist.AST.StoreRoot(Hime.Redist.AST.Node)">
            <summary>
            Stores the root of this tree
            </summary>
            <param name="node">The root</param>
        </member>
        <member name="T:Hime.Redist.ASTFamily">
            <summary>
            Represents a family of children for an ASTNode
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTFamily.tree">
            <summary>
            The original parse tree
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTFamily.parent">
            <summary>
            The index of the parent node in the parse tree
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTFamily.Count">
            <summary>
            Gets the number of children
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTFamily.Item(System.Int32)">
            <summary>
            Gets the i-th child
            </summary>
            <param name="index">The index of the child</param>
            <returns>The child at the given index</returns>
        </member>
        <member name="M:Hime.Redist.ASTFamily.GetEnumerator">
            <summary>
            Gets an enumeration of the children
            </summary>
            <returns>An enumeration of the children</returns>
        </member>
        <member name="M:Hime.Redist.ASTFamily.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumeration of the children
            </summary>
            <returns>An enumeration of the children</returns>
        </member>
        <member name="M:Hime.Redist.ASTFamily.#ctor(Hime.Redist.AST,System.Int32)">
            <summary>
            Initializes this family
            </summary>
            <param name="tree">The parent parse tree</param>
            <param name="parent">The index of the parent node in the parse tree</param>
        </member>
        <member name="T:Hime.Redist.ASTLabel">
            <summary>
            Represents a label an AST node
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTLabel.symbol">
            <summary>
            The symbol being referenced
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTLabel.type">
            <summary>
            The type of this symbol
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.SymbolType">
            <summary>
            Gets the type of symbol this element represents
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.Position">
            <summary>
            Gets the position in the input text of this element
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.Span">
            <summary>
            Gets the span in the input text of this element
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.Context">
            <summary>
            Gets the context of this element in the input
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.Symbol">
            <summary>
            Gets the grammar symbol associated to this element
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTLabel.Value">
            <summary>
            Gets the value of this element, if any
            </summary>
        </member>
        <member name="M:Hime.Redist.ASTLabel.#ctor(Hime.Redist.Symbol,Hime.Redist.SymbolType)">
            <summary>
            Initializes this reference
            </summary>
            <param name="symbol">The symbol being referenced</param>
            <param name="type">The type of this symbol</param>
        </member>
        <member name="M:Hime.Redist.ASTLabel.ToString">
            <summary>
            Gets a string representation of this token
            </summary>
            <returns>The string representation of the token</returns>
        </member>
        <member name="T:Hime.Redist.ASTNode">
            <summary>
            Represents a node in an Abstract Syntax Tree
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTNode.tree">
            <summary>
            The parent parse tree
            </summary>
        </member>
        <member name="F:Hime.Redist.ASTNode.index">
            <summary>
            The index of this node in the parse tree
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Parent">
            <summary>
            Gets the parent node, if any
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.SymbolType">
            <summary>
            Gets the type of symbol this element represents
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Children">
            <summary>
            Gets the children of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Position">
            <summary>
            Gets the position in the input text of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Span">
            <summary>
            Gets the span in the input text of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Context">
            <summary>
            Gets the context of this node in the input
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Symbol">
            <summary>
            Gets the grammar symbol associated to this node
            </summary>
        </member>
        <member name="P:Hime.Redist.ASTNode.Value">
            <summary>
            Gets the value of this node
            </summary>
        </member>
        <member name="M:Hime.Redist.ASTNode.#ctor(Hime.Redist.AST,System.Int32)">
            <summary>
            Initializes this node
            </summary>
            <param name="tree">The parent parse tree</param>
            <param name="index">The index of this node in the parse tree</param>
        </member>
        <member name="M:Hime.Redist.ASTNode.ToString">
            <summary>
            Gets a string representation of this node
            </summary>
            <returns>The string representation of this node</returns>
        </member>
        <member name="T:Hime.Redist.IncorrectEncodingSequence">
            <summary>
            Represents an incorrect encoding sequence error in the input of a lexer
            </summary>
        </member>
        <member name="F:Hime.Redist.IncorrectEncodingSequence.sequence">
            <summary>
            The incorrect sequence
            </summary>
        </member>
        <member name="F:Hime.Redist.IncorrectEncodingSequence.type">
            <summary>
            The precise error type
            </summary>
        </member>
        <member name="P:Hime.Redist.IncorrectEncodingSequence.Type">
            <summary>
            Gets the error's type
            </summary>
        </member>
        <member name="P:Hime.Redist.IncorrectEncodingSequence.Length">
            <summary>
            Gets the error's length in the input (in number of characters)
            </summary>
        </member>
        <member name="P:Hime.Redist.IncorrectEncodingSequence.Message">
            <summary>
            Gets the error's message
            </summary>
        </member>
        <member name="P:Hime.Redist.IncorrectEncodingSequence.Sequence">
            <summary>
            Gets the incorrect sequence
            </summary>
        </member>
        <member name="M:Hime.Redist.IncorrectEncodingSequence.#ctor(Hime.Redist.TextPosition,System.Char,Hime.Redist.ParseErrorType)">
            <summary>
            Initializes this error
            </summary>
            <param name="position">Error's position in the input</param>
            <param name="sequence">The incorrect sequence</param>
            <param name="errorType">The precise error type</param>
        </member>
        <member name="M:Hime.Redist.IncorrectEncodingSequence.BuildMessage">
            <summary>
            Builds the message for this error
            </summary>
            <returns>The message for this error</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.Automaton">
            <summary>
            Represents the automaton of a lexer
            </summary>
            <remarks>
            Binary data structure of lexers:
            uint32: number of entries in the states index table
            -- states offset table
            each entry is of the form:
            uint32: offset of the state from the beginning of the states table in number of uint16
            -- states table
            See AutomatonState
            </remarks>
        </member>
        <member name="F:Hime.Redist.Lexer.Automaton.DEAD_STATE">
            <summary>
            Identifier of inexistant state in an automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.Automaton.DEFAULT_CONTEXT">
            <summary>
            Identifier of the default context
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.Automaton.table">
            <summary>
            Table of indices in the states table
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.Automaton.states">
            <summary>
            Lexer's DFA table of states
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.Automaton.statesCount">
            <summary>
            The number of states in this automaton
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.Automaton.StatesCount">
            <summary>
            Gets the number of states in this automaton
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.Automaton.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new automaton from the given binary stream
            </summary>
            <param name="reader">The binary stream to load from</param>
            <remarks>
            This methods reads the necessary data from the reader assuming the reader only contains this automaton.
            It will read from reader until the end of the underlying stream.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Lexer.Automaton.Find(System.Type,System.String)">
            <summary>
            Loads an automaton from a resource
            </summary>
            <param name="type">The lexer's type</param>
            <param name="resource">The name of the resource containing the lexer</param>
            <returns>The automaton</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.Automaton.GetState(System.Int32)">
            <summary>
            Get the data of the specified state
            </summary>
            <param name="state">A state's index</param>
            <returns>The data of the specified state</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.AutomatonState">
            <summary>
            Represents a state in the automaton of a lexer
            </summary>
            <remarks>
            Binary data structure:
            uint16: number of matched terminals
            uint16: total number of transitions
            uint16: number of non-cached transitions
            -- matched terminals
            uint16: context identifier
            uint16: index of the matched terminal
            -- cache: 256 entries
            uint16: next state's index for index of the entry
            -- transitions
            each transition is of the form:
            uint16: start of the range
            uint16: end of the range
            uint16: next state's index
            </remarks>
        </member>
        <member name="F:Hime.Redist.Lexer.AutomatonState.table">
            <summary>
            The automaton table
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.AutomatonState.offset">
            <summary>
            The offset of this state within the table
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonState.#ctor(System.UInt16[],System.Int32)">
            <summary>
            Initializes this state
            </summary>
            <param name="table">The automaton table</param>
            <param name="offset">The offset of this state within the table</param>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonState.TerminalsCount">
            <summary>
            Gets the number of matched terminals in this state
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonState.GetTerminal(System.Int32)">
            <summary>
            Gets the i-th matched terminal in this state
            </summary>
            <param name="index">The index of the matched terminal</param>
            <returns>The matched terminal data</returns>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonState.IsDeadEnd">
            <summary>
            Gets whether this state is a dead end (no more transition)
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonState.BulkTransitionsCount">
            <summary>
            Gets the number of non-cached transitions in this state
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonState.GetTargetBy(System.Int32)">
            <summary>
            Gets the target of a transition from this state on the specified value
            </summary>
            <param name="value">An input value</param>
            <returns>The target of the transition</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonState.GetCachedTransition(System.Int32)">
            <summary>
            Gets the target of the cached transition for the specified value
            </summary>
            <param name="value">An input value</param>
            <returns>The target of the cached transition</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonState.GetBulkTransition(System.Int32)">
            <summary>
            Gets the i-th non-cached transition in this state
            </summary>
            <param name="index">The non-cached transition index</param>
            <returns>The transition</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.AutomatonTransition">
            <summary>
            Represents a transition in the automaton of a lexer
            A transition is matched by a range of UTF-16 code points
            Its target is a state in the automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.AutomatonTransition.start">
            <summary>
            Start of the range
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.AutomatonTransition.end">
            <summary>
            End of the range
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.AutomatonTransition.target">
            <summary>
            The transition's target
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonTransition.Start">
            <summary>
            Gets the start of the UTF-16 code point range
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonTransition.End">
            <summary>
            Gets the end of the UTF-16 code point range
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.AutomatonTransition.Target">
            <summary>
            Gets the target if this transition
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.AutomatonTransition.#ctor(System.UInt16[],System.Int32)">
            <summary>
            Initializes this transition
            </summary>
            <param name="table">The table containing the transition</param>
            <param name="offset">The offset of this transition in the table</param>
        </member>
        <member name="T:Hime.Redist.Lexer.AddLexicalError">
            <summary>
            Handler for lexical errors
            </summary>
            <param name="error">The new error</param>
        </member>
        <member name="T:Hime.Redist.Lexer.BaseLexer">
            <summary>
            Represents a base lexer
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.DEFAULT_RECOVERY_MATCHING_DISTANCE">
            <summary>
            The default maximum Levenshtein distance to go to for the recovery of a matching failure
            </summary>
        </member>
        <member name="T:Hime.Redist.Lexer.BaseLexer.DefaultContextProvider">
            <summary>
            The default context provider
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.DEFAULT_CONTEXT_PROVIDER">
            <summary>
            The default context provider
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.automaton">
            <summary>
            This lexer's automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.symTerminals">
            <summary>
            The terminals matched by this lexer
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.separatorID">
            <summary>
            Symbol ID of the SEPARATOR terminal
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.text">
            <summary>
            The input text
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseLexer.tokens">
            <summary>
            The token repository
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.BaseLexer.Terminals">
            <summary>
            Gets the terminals matched by this lexer
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.BaseLexer.Input">
            <summary>
            Gets the lexer's input text
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.BaseLexer.Output">
            <summary>
            Gets the lexer's output stream of tokens
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.BaseLexer.RecoveryDistance">
            <summary>
            Gets or sets the maximum Levenshtein distance to go to for the recovery of a matching failure.
            A distance of 0 indicates no recovery.
            </summary>
        </member>
        <member name="E:Hime.Redist.Lexer.BaseLexer.OnError">
            <summary>
            Events for lexical errors
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.String)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.IO.TextReader)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.GetNextToken">
            <summary>
            Gets the next token in the input
            </summary>
            <returns>The next token in the input</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.RunDFA(System.Int32)">
            <summary>
            Runs the lexer's DFA to match a terminal in the input ahead
            </summary>
            <param name="index">The current start index in the input text</param>
            <returns>The matching DFA state and length</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.RunDFAOnError(System.Int32)">
            <summary>
            When an error was encountered, runs the lexer's DFA to match a terminal in the input ahead
            </summary>
            <param name="originIndex">The current start index in the input text</param>
            <returns>The matching DFA state and length</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseLexer.GetNextToken(Hime.Redist.Lexer.IContextProvider)">
            <summary>
            Gets the next token in the input
            </summary>
            <param name="contexts">The current applicable contexts</param>
            <returns>The next token in the input</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.BaseText">
            <summary>
            Represents the base implementation of Text
            </summary>
            <remarks>
            All line numbers and column numbers are 1-based.
            Indices in the content are 0-based.
            </remarks>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseText.INIT_LINE_COUNT_CACHE_SIZE">
            <summary>
            The initial size of the cache of line start indices
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseText.lines">
            <summary>
            Cache of the starting indices of each line within the text
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.BaseText.line">
            <summary>
            Index of the next line
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetValue(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">Index from the start</param>
            <returns>The character at the specified index</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.IsEnd(System.Int32)">
            <summary>
            Gets whether the specified index is after the end of the text represented by this object
            </summary>
            <param name="index">Index from the start</param>
            <returns><c>true</c> if the index is after the end of the text</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.FindLines">
            <summary>
            Finds all the lines in this content
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.IsLineEnding(System.Char,System.Char)">
            <summary>
            Determines whether [c1, c2] form a line ending sequence
            </summary>
            <param name="c1">First character</param>
            <param name="c2">Second character</param>
            <returns><c>true</c> if this is a line ending sequence</returns>
            <remarks>
            Recognized sequences are:
            [U+000D, U+000A] (this is Windows-style \r \n)
            [U+????, U+000A] (this is unix style \n)
            [U+000D, U+????] (this is MacOS style \r, without \n after)
            Others:
            [?, U+000B], [?, U+000C], [?, U+0085], [?, U+2028], [?, U+2029]
            </remarks>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.AddLine(System.Int32)">
            <summary>
            Adds a line starting at the specified index
            </summary>
            <param name="index">An index in the content</param>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.FindLineAt(System.Int32)">
            <summary>
            Finds the index in the cache of the line at the given input index in the content
            </summary>
            <param name="index">The index within this content</param>
            <returns>The index of the corresponding line in the cache</returns>
        </member>
        <member name="P:Hime.Redist.Lexer.BaseText.LineCount">
            <summary>
            Gets the number of lines
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetValue(Hime.Redist.TextSpan)">
            <summary>
            Get the substring corresponding to the specified span
            </summary>
            <param name="span">A span in this text</param>
            <returns>The substring</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetLineIndex(System.Int32)">
            <summary>
            Gets the starting index of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The starting index of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetLineContent(System.Int32)">
            <summary>
            Gets the string content of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The string content of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetPositionAt(System.Int32)">
            <summary>
            Gets the position at the given index
            </summary>
            <param name="index">Index from the start</param>
            <returns>The position (line and column) at the index</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetContext(Hime.Redist.TextPosition)">
            <summary>
            Gets the context description for the current text at the specified position
            </summary>
            <param name="position">The position in this text</param>
            <returns>The context description</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetContext(Hime.Redist.TextPosition,System.Int32)">
            <summary>
            Gets the context description for the current text at the specified position
            </summary>
            <param name="position">The position in this text</param>
            <param name="length">The length of the element to contextualize</param>
            <returns>The context description</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.BaseText.GetContext(Hime.Redist.TextSpan)">
            <summary>
            Gets the context description for the current text at the specified span
            </summary>
            <param name="span">The span of text to contextualize</param>
            <returns>The context description</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.ContextFreeLexer">
            <summary>
            Represents a context-free lexer (lexing rules do not depend on the context)
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.ContextFreeLexer.tokenIndex">
            <summary>
            Index of the next token
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextFreeLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.String)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextFreeLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.IO.TextReader)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextFreeLexer.GetNextToken(Hime.Redist.Lexer.IContextProvider)">
            <summary>
            Gets the next token in the input
            </summary>
            <param name="contexts">The current applicable contexts</param>
            <returns>The next token in the input</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextFreeLexer.FindTokens">
            <summary>
            Finds all the tokens in the lexer's input
            </summary>
        </member>
        <member name="T:Hime.Redist.Lexer.ContextSensitiveLexer">
            <summary>
            Represents a context-free lexer (lexing rules do not depend on the context)
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.ContextSensitiveLexer.inputIndex">
            <summary>
            The current index in the input
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.ContextSensitiveLexer.isDollarEmitted">
            <summary>
            Whether the end-of-input dollar marker has already been emitted
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextSensitiveLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.String)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextSensitiveLexer.#ctor(Hime.Redist.Lexer.Automaton,Hime.Redist.Symbol[],System.Int32,System.IO.TextReader)">
            <summary>
            Initializes a new instance of the Lexer class with the given input
            </summary>
            <param name="automaton">DFA automaton for this lexer</param>
            <param name="terminals">Terminals recognized by this lexer</param>
            <param name="separator">SID of the separator token</param>
            <param name="input">Input to this lexer</param>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextSensitiveLexer.GetNextToken(Hime.Redist.Lexer.IContextProvider)">
            <summary>
            Gets the next token in the input
            </summary>
            <param name="contexts">The current applicable contexts</param>
            <returns>The next token in the input</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.ContextSensitiveLexer.GetTerminalFor(System.Int32,Hime.Redist.Lexer.IContextProvider)">
            <summary>
            Gets the index of the terminal with the highest priority that is possible in the contexts
            </summary>
            <param name="state">The DFA state</param>
            <param name="provider">The current applicable contexts</param>
            <returns>The index of the terminal</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.FuzzyMatcher">
            <summary>
            A fuzzy DFA matcher
            This matcher uses the Levenshtein distance to match the input ahead against the current DFA automaton.
            The matcher favors solutions that are the closest to the original input.
            When multiple solutions are at the same Levenshtein distance to the input, the longest one is preferred.
            </summary>
        </member>
        <member name="T:Hime.Redist.Lexer.FuzzyMatcher.Head">
            <summary>
            Represents a DFA stack head
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.Head.data">
            <summary>
            The data representing this head
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.FuzzyMatcher.Head.State">
            <summary>
            Gets the associated DFA state
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.FuzzyMatcher.Head.Distance">
            <summary>
            Gets the Levenshtein distance of this head form the input
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Head.#ctor(System.Int32)">
            <summary>
            Initializes this head with a state and a 0 distance
            </summary>
            <param name="state">The associated DFA state</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Head.#ctor(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32)">
            <summary>
            Initializes this head from a previous one
            </summary>
            <param name="previous">The previous head</param>
            <param name="state">The associated DFA state</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Head.#ctor(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes this head from a previous one
            </summary>
            <param name="previous">The previous head</param>
            <param name="state">The associated DFA state</param>
            <param name="offset">The offset of the error from the original index</param>
            <param name="distance">The distance to reach</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Head.GetError(System.Int32)">
            <summary>
            Gets the offset in the input of the i-th lexical error on this head
            </summary>
            <param name="i">Index of the error</param>
            <returns>The offset of the i-th error in the input</returns>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.automaton">
            <summary>
            This lexer's automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.separator">
            <summary>
            Terminal index of the SEPARATOR terminal
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.text">
            <summary>
            The input text
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.errors">
            <summary>
            Delegate for raising errors
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.maxDistance">
            <summary>
            The maximum Levenshtein distance between the input and the DFA
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.originIndex">
            <summary>
            The index in the input from wich the error was raised
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.heads">
            <summary>
            The current heads
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.insertions">
            <summary>
            Buffer of DFA states for the computation of character insertions
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.insertionsCount">
            <summary>
            The current number of insertions in the buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.matchHead">
            <summary>
            The current matching head, if any
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.FuzzyMatcher.matchLength">
            <summary>
            The current matching length
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.#ctor(Hime.Redist.Lexer.Automaton,System.Int32,Hime.Redist.Lexer.BaseText,Hime.Redist.Lexer.AddLexicalError,System.Int32,System.Int32)">
            <summary>
            Initializes this matcher
            </summary>
            <param name="automaton">This lexer's automaton</param>
            <param name="separator">Terminal index of the SEPARATOR terminal</param>
            <param name="text">The input text</param>
            <param name="errors">Delegate for raising errors</param>
            <param name="maxDistance">The maximum Levenshtein distance between the input and the DFA</param>
            <param name="index">The index in the input from wich the error was raised</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Run">
            <summary>
            Runs this matcher
            </summary>
            <returns>The solution</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.OnSuccess">
            <summary>
            Constructs the solution when succeeded to fix the error
            </summary>
            <returns>The constructed solution</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.OnError(System.Int32)">
            <summary>
            Reports on the lexical error at the specified index
            </summary>
            <param name="index">The index in the input where the error occurs</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.OnFailure">
            <summary>
            Constructs the solution when failed to fix the error
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.PushHead(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32)">
            <summary>
            Pushes a new head onto the the queue
            </summary>
            <param name="previous">The previous head</param>
            <param name="state">The associated DFA state</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.PushHead(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Int32)">
            <summary>
            Pushes a new head onto the the queue
            </summary>
            <param name="previous">The previous head</param>
            <param name="state">The associated DFA state</param>
            <param name="offset">The offset of the error from the original index</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.PushHead(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Int32,System.Int32)">
            <summary>
            Pushes a new head onto the the queue
            </summary>
            <param name="previous">The previous head</param>
            <param name="state">The associated DFA state</param>
            <param name="offset">The offset of the error from the original index</param>
            <param name="distance">The distance to reach</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.InspectAtEnd(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32)">
            <summary>
            Inspects a head while at the end of the input
            </summary>
            <param name="head">The head to inspect</param>
            <param name="offset">The current offset from the original index</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.Inspect(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Char)">
            <summary>
            Inspects a head with a specified character ahead
            </summary>
            <param name="head">The head to inspect</param>
            <param name="offset">The current offset from the original index</param>
            <param name="current">The leading character in the input</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.ExploreTransitions(Hime.Redist.Lexer.FuzzyMatcher.Head,Hime.Redist.Lexer.AutomatonState,System.Int32,System.Boolean)">
            <summary>
            Explores a state transition
            </summary>
            <param name="head">The current head</param>
            <param name="stateData">The data of the DFA state</param>
            <param name="offset">The current offset from the original index</param>
            <param name="atEnd">Whether the current index is at the end of the input</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.ExploreTransitionToTarget(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Explores a state transition
            </summary>
            <param name="head">The current head</param>
            <param name="target">The target DFA state</param>
            <param name="offset">The current offset from the original index</param>
            <param name="atEnd">Whether the current index is at the end of the input</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.ExploreInsertions(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Boolean,System.Char)">
            <summary>
            Explores the current insertions
            </summary>
            <param name="head">The head to inspect</param>
            <param name="offset">The current offset from the original index</param>
            <param name="atEnd">Whether the current index is at the end of the input</param>
            <param name="current">The leading character in the input</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.ExploreInsertion(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Boolean,System.Char,System.Int32,System.Int32)">
            <summary>
            Explores an insertion
            </summary>
            <param name="head">The head to inspect</param>
            <param name="offset">The current offset from the original index</param>
            <param name="atEnd">Whether the current index is at the end of the input</param>
            <param name="current">The leading character in the input</param>
            <param name="state">The DFA state for the insertion</param>
            <param name="distance">The distance associated to this insertion</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.OnMatchingHead(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32)">
            <summary>
            When a matching head is encountered
            </summary>
            <param name="head">The matching head</param>
            <param name="offset">The current offset from the original index</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.OnMatchingInsertion(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32,System.Int32,System.Int32)">
            <summary>
            When a matching insertion is encountered
            </summary>
            <param name="previous">The previous head</param>
            <param name="offset">The current offset from the original index</param>
            <param name="target">The DFA state for the insertion</param>
            <param name="distance">The distance associated to this insertion</param>
        </member>
        <member name="M:Hime.Redist.Lexer.FuzzyMatcher.GetComparableLength(Hime.Redist.Lexer.FuzzyMatcher.Head,System.Int32)">
            <summary>
            Computes the comparable length of the specified match
            </summary>
            <param name="head">The matching head</param>
            <param name="length">The matching length in the input</param>
            <returns>The comparable length</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.IContextProvider">
            <summary>
            Represents an entity providing information about the current contexts
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.IContextProvider.GetContextPriority(System.Int32,System.Int32)">
            <summary>
            Gets the priority of the specified context required by the specified terminal
            The priority is a positive integer. The lesser the value the higher the priority.
            A negative value represents the unavailability of the required context.
            </summary>
            <param name="context">A context</param>
            <param name="onTerminalID">The identifier of the terminal requiring the context</param>
            <returns>The context priority, or a negative value if the context is unavailable</returns>
        </member>
        <member name="T:Hime.Redist.Lexer.MatchedTerminal">
            <summary>
            Represents the information of a terminal matched at the state of a lexer's automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.MatchedTerminal.context">
            <summary>
            The context
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.MatchedTerminal.index">
            <summary>
            The terminal's index
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.MatchedTerminal.Context">
            <summary>
            Gets the context required for the terminal to be matched
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.MatchedTerminal.Index">
            <summary>
            Gets the index of the matched terminal in the terminal table of the associated lexer
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.MatchedTerminal.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Initializes this matched terminal data
            </summary>
            <param name="context">The context</param>
            <param name="index">The terminal's index</param>
        </member>
        <member name="T:Hime.Redist.Lexer.PrefetchedText">
            <summary>
            Text provider that fetches and stores the full content of an input lexer
            </summary>
            <remarks>
            All line numbers and column numbers are 1-based.
            Indices in the content are 0-based.
            </remarks>
        </member>
        <member name="F:Hime.Redist.Lexer.PrefetchedText.content">
            <summary>
            The full content of the input
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.#ctor(System.String)">
            <summary>
            Initializes this text
            </summary>
            <param name="content">The full lexer's input as a string</param>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.GetValue(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">Index from the start</param>
            <returns>The character at the specified index</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.IsEnd(System.Int32)">
            <summary>
            Gets whether the specified index is after the end of the text represented by this object
            </summary>
            <param name="index">Index from the start</param>
            <returns><c>true</c> if the index is after the end of the text</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.FindLines">
            <summary>
            Finds all the lines in this content
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.PrefetchedText.Size">
            <summary>
            Gets the size in number of characters
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.GetValue(System.Int32,System.Int32)">
            <summary>
            Gets the substring beginning at the given index with the given length
            </summary>
            <param name="index">Index of the substring from the start</param>
            <param name="length">Length of the substring</param>
            <returns>The substring</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.PrefetchedText.GetLineLength(System.Int32)">
            <summary>
            Gets the length of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The length of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="T:Hime.Redist.Lexer.StreamingText">
            <summary>
            Text provider that uses a stream as a backend
            </summary>
            <remarks>
            All line numbers and column numbers are 1-based.
            Indices in the content are 0-based.
            </remarks>
        </member>
        <member name="F:Hime.Redist.Lexer.StreamingText.BLOCK_SIZE">
            <summary>
            The size of text block
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.StreamingText.input">
            <summary>
            The input to use
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.StreamingText.content">
            <summary>
            The content read so far
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.StreamingText.buffer">
            <summary>
            A buffer for reading text
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.StreamingText.atEnd">
            <summary>
            Whether the complete input has been read
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.#ctor(System.IO.TextReader)">
            <summary>
            Initializes this text
            </summary>
            <param name="input">The input text</param>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.MakeAvailable(System.Int32)">
            <summary>
            Reads the input so as to make the specified index available
            </summary>
            <param name="index">An index from the start</param>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.GetValue(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">Index from the start</param>
            <returns>The character at the specified index</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.IsEnd(System.Int32)">
            <summary>
            Gets whether the specified index is after the end of the text represented by this object
            </summary>
            <param name="index">Index from the start</param>
            <returns><c>true</c> if the index is after the end of the text</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.FindLines">
            <summary>
            Finds all the lines in this content
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.StreamingText.Size">
            <summary>
            Gets the size in number of characters
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.GetValue(System.Int32,System.Int32)">
            <summary>
            Gets the substring beginning at the given index with the given length
            </summary>
            <param name="index">Index of the substring from the start</param>
            <param name="length">Length of the substring</param>
            <returns>The substring</returns>
        </member>
        <member name="M:Hime.Redist.Lexer.StreamingText.GetLineLength(System.Int32)">
            <summary>
            Gets the length of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The length of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="T:Hime.Redist.Lexer.TokenKernel">
            <summary>
            Represents the kernel of a token, i.e. the identifying information of a token
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.TokenKernel.terminalID">
            <summary>
            The identifier of the matched terminal
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.TokenKernel.index">
            <summary>
            The token's index in its repository
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.TokenKernel.TerminalID">
            <summary>
            Gets the identifier of the matched terminal
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.TokenKernel.Index">
            <summary>
            Gets the token's index in its repository
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.TokenKernel.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes this kernel
            </summary>
            <param name="id">The identifier of the matched terminal</param>
            <param name="index">The token's index in its repository</param>
        </member>
        <member name="T:Hime.Redist.Lexer.TokenMatch">
            <summary>
            Represents a match in the input
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.TokenMatch.state">
            <summary>
            The matching DFA state
            </summary>
        </member>
        <member name="F:Hime.Redist.Lexer.TokenMatch.length">
            <summary>
            Length of the matched input
            </summary>
        </member>
        <member name="P:Hime.Redist.Lexer.TokenMatch.IsSuccess">
            <summary>
            Gets whether this is match indicates a success
            </summary>
        </member>
        <member name="M:Hime.Redist.Lexer.TokenMatch.#ctor(System.Int32)">
            <summary>
            Initializes a failing match
            </summary>
            <param name='length'>The number of characters to advance in the input</param>
        </member>
        <member name="M:Hime.Redist.Lexer.TokenMatch.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a match
            </summary>
            <param name='state'>The matching DFA state</param>
            <param name='length'>Length of the matched input</param>
        </member>
        <member name="T:Hime.Redist.ParseError">
            <summary>
            Represents an error in a parser
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseError.position">
            <summary>
            The error's position in the input text
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseError.Type">
            <summary>
            Gets the error's type
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseError.Position">
            <summary>
            Gets the error's position in the input
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseError.Length">
            <summary>
            Gets the error's length in the input (in number of characters)
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseError.Message">
            <summary>
            Gets the error's message
            </summary>
        </member>
        <member name="M:Hime.Redist.ParseError.#ctor(Hime.Redist.TextPosition)">
            <summary>
            Initializes this error
            </summary>
            <param name="position">Error's position in the input</param>
        </member>
        <member name="M:Hime.Redist.ParseError.ToString">
            <summary>
            Returns the string representation of this error
            </summary>
            <returns>The string representation of this error</returns>
        </member>
        <member name="T:Hime.Redist.ParseErrorType">
            <summary>
            Specifies the type of error
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseErrorType.UnexpectedEndOfInput">
            <summary>
            Lexical error occurring when the end of input has been encountered while more characters were expected
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseErrorType.UnexpectedChar">
            <summary>
            Lexical error occurring when an unexpected character is encountered in the input preventing to match tokens
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseErrorType.UnexpectedToken">
            <summary>
            Syntactic error occurring when an unexpected token is encountered by the parser
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseErrorType.IncorrectUTF16NoLowSurrogate">
            <summary>
            Lexical error occurring when the low surrogate encoding point is missing in a UTF-16 encoding sequence with an expected high and low surrogate pair
            </summary>
        </member>
        <member name="F:Hime.Redist.ParseErrorType.IncorrectUTF16NoHighSurrogate">
            <summary>
            Lexical error occurring when the high surrogate encoding point is missing in a UTF-16 encoding sequence with an expected high and low surrogate pair
            </summary>
        </member>
        <member name="T:Hime.Redist.ParseResult">
            <summary>
            Represents the output of a parser
            </summary>
        </member>
        <member name="M:Hime.Redist.ParseResult.#ctor(Hime.Redist.Utils.ROList{Hime.Redist.ParseError},Hime.Redist.Text)">
            <summary>
            Initializes this result as a failure
            </summary>
            <param name="errors">The list of errors</param>
            <param name="text">The parsed text</param>
        </member>
        <member name="M:Hime.Redist.ParseResult.#ctor(Hime.Redist.Utils.ROList{Hime.Redist.ParseError},Hime.Redist.Text,Hime.Redist.AST)">
            <summary>
            Initializes this result as a success with the given AST
            </summary>
            <param name="errors">The list of errors</param>
            <param name="text">The parsed text</param>
            <param name="ast">The produced AST</param>
        </member>
        <member name="P:Hime.Redist.ParseResult.IsSuccess">
            <summary>
            Gets whether the parser was successful
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseResult.Errors">
            <summary>
            Gets a list of the parsing errors
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseResult.Input">
            <summary>
            Gets the text that has been parsed
            </summary>
        </member>
        <member name="P:Hime.Redist.ParseResult.Root">
            <summary>
            Gets the root of the produced parse tree
            </summary>
        </member>
        <member name="M:Hime.Redist.ParseResult.FindTokenAt(System.Int32)">
            <summary>
            Gets the token (if any) that contains the specified index in the input text
            </summary>
            <param name="index">An index within the input text</param>
            <returns>The token, if any</returns>
        </member>
        <member name="M:Hime.Redist.ParseResult.FindTokenAt(Hime.Redist.TextPosition)">
            <summary>
            Gets the token (if any) that contains the specified position in the input text
            </summary>
            <param name="position">A position within the input text</param>
            <returns>The token, if any</returns>
        </member>
        <member name="M:Hime.Redist.ParseResult.FindNodeFor(Hime.Redist.Token)">
            <summary>
            Gets the AST node (if any) that has the specified token as label
            </summary>
            <param name="token">The token to look for</param>
            <returns>The AST node, if any</returns>
        </member>
        <member name="M:Hime.Redist.ParseResult.FindNodeAt(System.Int32)">
            <summary>
            Gets the AST node (if any) that has a token label that contains the specified index in the input text
            </summary>
            <param name="index">An index within the input text</param>
            <returns>The AST node, if any</returns>
        </member>
        <member name="M:Hime.Redist.ParseResult.FindNodeAt(Hime.Redist.TextPosition)">
            <summary>
            Gets the AST node (if any) that has a token label that contains the specified position in the input text
            </summary>
            <param name="position">A position within the input text</param>
            <returns>The AST node, if any</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.BaseLRParser">
            <summary>
            Represents a base LR parser
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.MAX_ERROR_COUNT">
            <summary>
            Maximum number of errors
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.DEFAULT_MODE_RECOVER">
            <summary>
            The default value of the recover mode
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.DEFAULT_MODE_DEBUG">
            <summary>
            The default value of the debug mode
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.symVariables">
            <summary>
            Parser's variable symbols
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.symVirtuals">
            <summary>
            Parser's virtual symbols
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.symActions">
            <summary>
            Parser's action symbols
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.allErrors">
            <summary>
            List of the encountered syntaxic errors
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.BaseLRParser.lexer">
            <summary>
            Lexer associated to this parser
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.BaseLRParser.SymbolVariables">
            <summary>
            Gets the variable symbols used by this parser
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.BaseLRParser.SymbolVirtuals">
            <summary>
            Gets the virtual symbols used by this parser
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.BaseLRParser.SymbolActions">
            <summary>
            Gets the action symbols used by this parser
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.BaseLRParser.ModeRecoverErrors">
            <summary>
            Gets or sets whether the paser should try to recover from errors
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.BaseLRParser.ModeDebug">
            <summary>
            Gets or sets a value indicating whether this parser is in debug mode
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.BaseLRParser.#ctor(Hime.Redist.Symbol[],Hime.Redist.Symbol[],Hime.Redist.SemanticAction[],Hime.Redist.Lexer.BaseLexer)">
            <summary>
            Initializes a new instance of the LRkParser class with the given lexer
            </summary>
            <param name="variables">The parser's variables</param>
            <param name="virtuals">The parser's virtuals</param>
            <param name="actions">The parser's actions</param>
            <param name="lexer">The input lexer</param>
        </member>
        <member name="M:Hime.Redist.Parsers.BaseLRParser.OnLexicalError(Hime.Redist.ParseError)">
            <summary>
            Adds the given lexical error emanating from the lexer to the list of errors
            </summary>
            <param name="error">Lexical error</param>
        </member>
        <member name="M:Hime.Redist.Parsers.BaseLRParser.Parse">
            <summary>
            Parses the input and returns the result
            </summary>
            <returns>A ParseResult object containing the data about the result</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.ColumnMap">
            <summary>
            Represent a map from symbols' IDs to the index of their corresponding column in an LR table.
            It is optimized for IDs from 0x0000 to 0x01FF (the first 512 symbols) with hope they are the most frequent.
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.ColumnMap.cache1">
            <summary>
            Cache for ids from 0x00 to 0xFF
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.ColumnMap.cache2">
            <summary>
            Cache for ids from 0x100 to 0x1FF
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.ColumnMap.others">
            <summary>
            Hashmap for the other ids
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.ColumnMap.#ctor">
            <summary>
            Initializes the structure
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.ColumnMap.Add(System.Int32,System.Int32)">
            <summary>
            Adds a new data in the collection with the given key
            </summary>
            <param name="key">The key for the data</param>
            <param name="value">The data</param>
        </member>
        <member name="P:Hime.Redist.Parsers.ColumnMap.Item(System.Int32)">
            <summary>
            Gets the data for the given key
            </summary>
            <param name="key">The key for the data</param>
            <returns>The data corresponding to the key</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.GSS">
            <summary>
            Represents Graph-Structured Stacks for GLR parsers
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.INIT_PATHS_COUNT">
            <summary>
            The initial size of the paths buffer in this GSS
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.nodeLabels">
            <summary>
            The label (GLR state) on the GSS node for the given index
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.nodeGenerations">
            <summary>
            The generations of nodes in this GSS
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.edges">
            <summary>
            The edges in this GSS
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.edgeGenerations">
            <summary>
            The generations for the edges
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.generation">
            <summary>
            Index of the current generation
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.path0">
            <summary>
            A single reusable GSS paths for returning 0-length GSS paths
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.paths0">
            <summary>
            The single reusable buffer for returning 0-length GSS paths
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSS.paths">
            <summary>
            A buffer of GSS paths
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.#ctor">
            <summary>
            Initializes the GSS
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.GetGeneration">
            <summary>
            Gets the data of the current generation
            </summary>
            <returns>The generation's data</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.GetGeneration(System.Int32)">
            <summary>
            Gets the data of the specified generation of nodes
            </summary>
            <param name="generation">A generation</param>
            <returns>The generation's data</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.GetRepresentedState(System.Int32)">
            <summary>
            Gets the GLR state represented by the specified node
            </summary>
            <param name="node">A node</param>
            <returns>The GLR state represented by the node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.FindNode(System.Int32,System.Int32)">
            <summary>
            Finds in the given generation a node representing the given GLR state
            </summary>
            <param name="generation">A generation</param>
            <param name="state">A GLR state</param>
            <returns>The node representing the GLR state, or -1 if it is not found</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.HasEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            Determines whether this instance has the required edge
            </summary>
            <param name="generation">The generation of the edge's start node</param>
            <param name="from">The edge's start node</param>
            <param name="to">The edge's target node</param>
            <returns><c>true</c> if this instance has the required edge; otherwise, <c>false</c></returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.CreateGeneration">
            <summary>
            Opens a new generation in this GSS
            </summary>
            <returns>The index of the new generation</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.CreateNode(System.Int32)">
            <summary>
            Creates a new node in the GSS
            </summary>
            <param name="state">The GLR state represented by the node</param>
            <returns>The node's identifier</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.CreateEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new edge in the GSS
            </summary>
            <param name="from">The edge's starting node</param>
            <param name="to">The edge's target node</param>
            <param name="label">The edge's label</param>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.SetupPath(System.Int32,System.Int32,System.Int32)">
            <summary>
            Setups a reusable GSS path with the given length
            </summary>
            <param name="index">The index in the buffer of reusable paths</param>
            <param name="last">The last GLR state in the path</param>
            <param name="length">The path's length</param>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.GetGenerationOf(System.Int32)">
            <summary>
            Retrieve the generation of the given node in this GSS
            </summary>
            <param name="node">A node's index</param>
            <returns>The index of the generation containing the node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.GetPaths(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Gets all paths in the GSS starting at the given node and with the given length
            </summary>
            <param name="from">The starting node</param>
            <param name="length">The length of the requested paths</param>
            <param name="count">The number of paths</param>
            <returns>A collection of paths in this GSS</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.Print">
            <summary>
            Prints this stack onto the console output
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.PrintTo(System.String)">
            <summary>
            Prints this stack into the specified file
            </summary>
            <param name="file">The file to print to</param>
        </member>
        <member name="M:Hime.Redist.Parsers.GSS.PrintTo(System.IO.TextWriter)">
            <summary>
            Prints this stack with the specified writer
            </summary>
            <param name="writer">A text writer</param>
        </member>
        <member name="T:Hime.Redist.Parsers.GSSEdge">
            <summary>
            Represents an edge in a Graph-Structured Stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSEdge.from">
            <summary>
            The index of the node from which this edge starts
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSEdge.to">
            <summary>
            The index of the node to which this edge arrives to
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSEdge.label">
            <summary>
            The identifier of the SPPF node that serve as label for this edge
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSEdge.From">
            <summary>
            Gets the index of the node from which this edge starts
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSEdge.To">
            <summary>
            Gets the index of the node to which this edge arrives to
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSEdge.Label">
            <summary>
            Gets the identifier of the SPPF node that serve as label for this edge
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSEdge.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes this edge
            </summary>
            <param name="from">Index of the node from which this edge starts</param>
            <param name="to">Index of the node to which this edge arrives to</param>
            <param name="label">The identifier of the SPPF node that serve as label for this edge</param>
        </member>
        <member name="T:Hime.Redist.Parsers.GSSGeneration">
            <summary>
            Represents a generation in a Graph-Structured Stack
            </summary>
            <remarks>
            Because GSS nodes and edges are always created sequentially,
            a generation basically describes a span in a buffer of GSS nodes or edges
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSGeneration.start">
            <summary>
            The start index of this generation in the list of nodes
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSGeneration.count">
            <summary>
            The number of nodes in this generation
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSGeneration.Start">
            <summary>
            Gets the start index of this generation in the list of nodes
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSGeneration.Count">
            <summary>
            Gets or sets the number of nodes in this generation
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSGeneration.#ctor(System.Int32)">
            <summary>
            Initializes this generation
            </summary>
            <param name="start">The start index of this generation in the list of nodes</param>
        </member>
        <member name="T:Hime.Redist.Parsers.GSSPath">
            <summary>
            Represents a path in a GSS
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSPath.INIT_BUFFER_SIZE">
            <summary>
            The initial size of the label buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.GSSPath.labels">
            <summary>
            The labels on this GSS path
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSPath.Last">
            <summary>
            Gets or sets the final target of this path
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSPath.Generation">
            <summary>
            Gets or sets the generation containing the final target of this path
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.GSSPath.Item(System.Int32)">
            <summary>
            Gets or sets the i-th label of the edges traversed by this path
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSPath.#ctor(System.Int32)">
            <summary>
            Initializes this path
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSPath.#ctor">
            <summary>
            Initializes this path
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSPath.Ensure(System.Int32)">
            <summary>
            Ensure the specified length of the label buffer
            </summary>
            <param name="length">The required length</param>
        </member>
        <member name="M:Hime.Redist.Parsers.GSSPath.CopyLabelsFrom(Hime.Redist.Parsers.GSSPath,System.Int32)">
            <summary>
            Copy the content of another path to this one
            </summary>
            <param name="path">The path to copy</param>
            <param name="length">The path's length</param>
        </member>
        <member name="T:Hime.Redist.Parsers.LRAction">
            <summary>
            Represents a LR action in a LR parse table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRAction.code">
            <summary>
            The LR action code
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRAction.data">
            <summary>
            The data associated with the action
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRAction.Code">
            <summary>
            Gets the action code
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRAction.Data">
            <summary>
            Gets the data associated with the action
            </summary>
            <remarks>
            If the code is Reduce, it is the index of the LRProduction
            If the code is Shift, it is the index of the next state
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.LRAction.#ctor(System.IO.BinaryReader)">
            <summary>
            Loads this LR Action from the specified input
            </summary>
            <param name="input">An input</param>
        </member>
        <member name="T:Hime.Redist.Parsers.LRActionCode">
            <summary>
            Represents an action in a LR parser
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRActionCode.None">
            <summary>
            No possible action => Error
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRActionCode.Reduce">
            <summary>
            Apply a reduction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRActionCode.Shift">
            <summary>
            Shift to another state
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRActionCode.Accept">
            <summary>
            Accept the input
            </summary>
        </member>
        <member name="T:Hime.Redist.Parsers.LRContexts">
            <summary>
            Represents the contexts opening by transitions from a state
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRContexts.content">
            <summary>
            The contexts
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRContexts.Count">
            <summary>
            Gets the number of contexts
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRContexts.#ctor(System.IO.BinaryReader)">
            <summary>
            Loads the contexts from the specified input
            </summary>
            <param name="input">An input</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRContexts.Opens(System.Int32,System.Int32)">
            <summary>
            Gets whether the specified context opens by a transition using the specified terminal ID
            </summary>
            <param name="terminalID">The identifier of a terminal</param>
            <param name="context">A context</param>
            <returns><c>true</c> if the specified context is opened</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.LRExpected">
            <summary>
            Container for the expected terminals for a LR state
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRExpected.shifts">
            <summary>
            The terminals expected for shift actions
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRExpected.reductions">
            <summary>
            The terminals expected for reduction actions
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRExpected.Shifts">
            <summary>
            Gets the terminals expected for shift actions
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRExpected.Reductions">
            <summary>
            Gets the terminals expected for a reduction actions
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRExpected.#ctor">
            <summary>
            Initializes this container
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRExpected.AddUniqueShift(Hime.Redist.Symbol)">
            <summary>
            Adds the specified terminal as expected on a shift action
            </summary>
            <param name="terminal">The terminal</param>
            <remarks>
            If the terminal is already added to the reduction collection it is removed from it.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.LRExpected.AddUniqueReduction(Hime.Redist.Symbol)">
            <summary>
            Adds the specified terminal as expected on a reduction action
            </summary>
            <param name="terminal">The terminal</param>
            <remarks>
            If the terminal is in the shift collection, nothing happens.
            </remarks>
        </member>
        <member name="T:Hime.Redist.Parsers.LRkASTBuilder">
            <summary>
            Represents the builder of Parse Trees for LR(k) parsers
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.INIT_HANDLE_SIZE">
            <summary>
            The initial size of the reduction handle
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.ESTIMATION_BIAS">
            <summary>
            The bias for estimating the size of the reduced sub-tree
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.poolSingle">
            <summary>
            The pool of single node sub-trees
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.pool128">
            <summary>
            The pool of sub-tree with a capacity of 128 nodes
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.pool1024">
            <summary>
            The pool of sub-tree with a capacity of 1024 nodes
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.stack">
            <summary>
            The stack of semantic objects
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.stackNext">
            <summary>
            Index of the available cell on top of the stack's head
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.cache">
            <summary>
            The sub-tree build-up cache
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.cacheNext">
            <summary>
            The new available node in the current cache
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.popCount">
            <summary>
            The number of items popped from the stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.handle">
            <summary>
            The reduction handle represented as the indices of the sub-trees in the cache
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.handleNext">
            <summary>
            The index of the next available slot in the handle
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkASTBuilder.result">
            <summary>
            The AST being built
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRkASTBuilder.Item(System.Int32)">
            <summary>
            Gets the symbol at the i-th index
            </summary>
            <param name="index">Index of the symbol</param>
            <returns>The symbol at the given index</returns>
        </member>
        <member name="P:Hime.Redist.Parsers.LRkASTBuilder.Length">
            <summary>
            Gets the length of this body
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.#ctor(Hime.Redist.TokenRepository,Hime.Redist.Utils.ROList{Hime.Redist.Symbol},Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Initializes the builder with the given stack size
            </summary>
            <param name="tokens">The table of tokens</param>
            <param name="variables">The table of parser variables</param>
            <param name="virtuals">The table of parser virtuals</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.StackPushToken(System.Int32)">
            <summary>
            Push a token onto the stack
            </summary>
            <param name="index">The token's index in the parsed text</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.ReductionPrepare(System.Int32,System.Int32,Hime.Redist.TreeAction)">
            <summary>
            Prepares for the forthcoming reduction operations
            </summary>
            <param name="varIndex">The reduced variable index</param>
            <param name="length">The length of the reduction</param>
            <param name="action">The tree action applied onto the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.GetSubTree(System.Int32)">
            <summary>
            Gets a pooled sub-tree with the given maximal size
            </summary>
            <param name="size">The size of the sub-tree</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.ReductionAddSub(Hime.Redist.Parsers.SubTree,Hime.Redist.TreeAction)">
            <summary>
            During a reduction, insert the given sub-tree
            </summary>
            <param name="sub">The sub-tree</param>
            <param name="action">The tree action applied onto the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.ReductionPop(Hime.Redist.TreeAction)">
            <summary>
            During a redution, pops the top symbol from the stack and gives it a tree action
            </summary>
            <param name="action">The tree action to apply to the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.ReductionAddVirtual(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            During a reduction, inserts a virtual symbol
            </summary>
            <param name="index">The virtual symbol's index</param>
            <param name="action">The tree action applied onto the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.Reduce">
            <summary>
            Finalizes the reduction operation
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.ReduceTree">
            <summary>
            Applies the promotion tree actions to the cache and commits to the final AST
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkASTBuilder.GetTree">
            <summary>
            Finalizes the parse tree and returns it
            </summary>
            <returns>The final parse tree</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.LRkAutomaton">
            <summary>
            Represents the LR(k) parsing table and productions
            </summary>
            <remarks>
            Binary data of a LR(k) parser
            --- header
            uint16: number of columns
            uint16: number of states
            uint16: number of productions
            --- parse table columns
            uint16: sid of the column
            --- parse table
            See LRActions
            --- productions table
            See LRProduction
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.ncols">
            <summary>
            The number of columns in the LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.nstates">
            <summary>
            The number of states in the LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.columns">
            <summary>
            Map of symbol ID to column index in the LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.contexts">
            <summary>
            The contexts information
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.table">
            <summary>
            The LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkAutomaton.productions">
            <summary>
            The table of LR productions
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRkAutomaton.StatesCount">
            <summary>
            Gets the number of states in this automaton
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new automaton from the given binary stream
            </summary>
            <param name="reader">The binary stream to load from</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.Find(System.Type,System.String)">
            <summary>
            Loads an automaton from a resource
            </summary>
            <param name="type">The lexer's type</param>
            <param name="resource">The name of the resource containing the lexer</param>
            <returns>The automaton</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.GetContexts(System.Int32)">
            <summary>
            Gets the contexts opened by the specified state
            </summary>
            <param name="state">State in the LR(k) automaton</param>
            <returns>The opened contexts</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.GetAction(System.Int32,System.Int32)">
            <summary>
            Gets the LR(k) action for the given state and sid
            </summary>
            <param name="state">State in the LR(k) automaton</param>
            <param name="sid">Symbol's ID</param>
            <returns>The LR(k) action for the state and sid</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.GetProduction(System.Int32)">
            <summary>
            Gets the production at the given index
            </summary>
            <param name="index">Production's index</param>
            <returns>The production a the given index</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkAutomaton.GetExpected(System.Int32,Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Gets the expected terminals for the specified state
            </summary>
            <param name="state">The DFA state</param>
            <param name="terminals">The possible terminals</param>
            <returns>The expected terminals</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.LRkParser">
            <summary>
            Represents a base for all LR(k) parsers
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.INIT_STACK_SIZE">
            <summary>
            Initial size of the stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.automaton">
            <summary>
            The parser's automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.stack">
            <summary>
            The parser's stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.stackIDs">
            <summary>
            The identifiers of the items on the stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.head">
            <summary>
            Index of the stack's head
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRkParser.builder">
            <summary>
            The AST builder
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.#ctor(Hime.Redist.Parsers.LRkAutomaton,Hime.Redist.Symbol[],Hime.Redist.Symbol[],Hime.Redist.SemanticAction[],Hime.Redist.Lexer.BaseLexer)">
            <summary>
            Initializes a new instance of the parser
            </summary>
            <param name="automaton">The parser's automaton</param>
            <param name="variables">The parser's variables</param>
            <param name="virtuals">The parser's virtuals</param>
            <param name="actions">The parser's actions</param>
            <param name="lexer">The input lexer</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.GetContextPriority(System.Int32,System.Int32)">
            <summary>
            Gets the priority of the specified context required by the specified terminal
            The priority is a positive integer. The lesser the value the higher the priority.
            A value of -1 represents the unavailability of the required context.
            </summary>
            <param name="context">A context</param>
            <param name="onTerminalID">The identifier of the terminal requiring the context</param>
            <returns>The context priority, or -1 if the context is unavailable</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.OnUnexpectedToken(Hime.Redist.Lexer.TokenKernel)">
            <summary>
            Raises an error on an unexpected token
            </summary>
            <param name="kernel">The unexpected token's kernel</param>
            <returns>The next token kernel in the case the error is recovered</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.CheckIsExpected(Hime.Redist.Symbol)">
            <summary>
            Checks whether the specified terminal is indeed expected for a reduction
            </summary>
            <param name="terminal">The terminal to check</param>
            <returns><code>true</code> if the terminal is really expected</returns>
            <remarks>
            This check is required because in the case of a base LALR graph,
            some terminals expected for reduction in the automaton are coming from other paths.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.Parse">
            <summary>
            Parses the input and returns the result
            </summary>
            <returns>A ParseResult object containing the data about the result</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.ParseOnToken(Hime.Redist.Lexer.TokenKernel)">
            <summary>
            Parses on the specified token kernel
            </summary>
            <param name="kernel">The token kernel to parse on</param>
            <returns>The LR action that was used</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.LRkParser.Reduce(Hime.Redist.Parsers.LRProduction)">
            <summary>
            Executes the given LR reduction
            </summary>
            <param name="production">A LR reduction</param>
        </member>
        <member name="T:Hime.Redist.Parsers.LROpCode">
            <summary>
            Represent an op-code for a LR production
            An op-code can be either an instruction or raw data
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCode.MASK_TREE_ACTION">
            <summary>
            Bit mask for the tree action part of an instruction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCode.MASK_BASE">
            <summary>
            Bit mask for the base part of an instruction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCode.code">
            <summary>
            The op-code value
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LROpCode.DataValue">
            <summary>
            Gets the value of the data interpretation of this op-code
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LROpCode.TreeAction">
            <summary>
            Gets the tree action included in this code
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LROpCode.Base">
            <summary>
            Gets the base instruction in this code
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.LROpCode.#ctor(System.IO.BinaryReader)">
            <summary>
            Loads this op-code from the specified input
            </summary>
            <param name="input">An input</param>
        </member>
        <member name="T:Hime.Redist.Parsers.LROpCodeBase">
            <summary>
            Base values of LR op-code instructions
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeBase.PopStack">
            <summary>
            Pop an AST from the stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeBase.AddVirtual">
            <summary>
            Add a virtual symbol
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeBase.SemanticAction">
            <summary>
            Execute a semantic action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeBase.AddNullVariable">
            <summary>
            Add a null variable
            </summary>
            <remarks>
            This can be found only in RNGLR productions
            </remarks>
        </member>
        <member name="T:Hime.Redist.Parsers.LROpCodeValues">
            <summary>
            Enumeration of the LR op codes
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.PopStackNoAction">
            <summary>
            Pop an AST from the stack without applying any tree action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.PopStackDrop">
            <summary>
            Pop an AST from the stack and apply the drop tree action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.PopStackPromote">
            <summary>
            Pop an AST from the stack and apply the promote tree action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddVirtualNoAction">
            <summary>
            Add a virtual symbol without tree action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddVirtualDrop">
            <summary>
            Add a virtual symbol and apply the drop tree action
            </summary>
            <remarks>
            This doesn't make any sense, but it is possible!
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddVirtualPromote">
            <summary>
            Add a virtual symbol and apply the promote tree action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.SemanticAction">
            <summary>
            Execute a semantic action
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddNullVariableNoAction">
            <summary>
            Add a null variable without any tree action
            </summary>
            <remarks>
            This can be found only in RNGLR productions
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddNullVariableDrop">
            <summary>
            Add a null variable and apply the drop tree action
            </summary>
            <remarks>
            This can be found only in RNGLR productions
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.LROpCodeValues.AddNullVariablePromote">
            <summary>
            Add a null variable and apply the promote action
            </summary>
            <remarks>
            This can be found only in RNGLR productions
            </remarks>
        </member>
        <member name="T:Hime.Redist.Parsers.LRProduction">
            <summary>
            Represents a rule's production in a LR parser
            </summary>
            <remarks>
            The binary representation of a LR Production is as follow:
            --- header
            uint16: head's index
            uint8: 1=replace, 0=nothing
            uint8: reduction length
            uint8: bytecode length in number of op-code
            --- production's bytecode
            See LRBytecode
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.LRProduction.head">
            <summary>
            Index of the rule's head in the parser's array of variables
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRProduction.headAction">
            <summary>
            Action of the rule's head (replace or not)
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRProduction.reducLength">
            <summary>
            Size of the rule's body by only counting terminals and variables
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.LRProduction.bytecode">
            <summary>
            Bytecode for the rule's production
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRProduction.Head">
            <summary>
            Gets the index of the rule's head in the parser's array of variables
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRProduction.HeadAction">
            <summary>
            Gets the action of the rule's head (replace or not)
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRProduction.ReductionLength">
            <summary>
            Gets the size of the rule's body by only counting terminals and variables
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRProduction.BytecodeLength">
            <summary>
            Gets the length of the bytecode
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.LRProduction.Item(System.Int32)">
            <summary>
            Gets the op-code at the specified index in the bytecode
            </summary>
            <param name="index">Index in the bytecode</param>
        </member>
        <member name="M:Hime.Redist.Parsers.LRProduction.#ctor(System.IO.BinaryReader)">
            <summary>
            Loads a new instance of the LRProduction class from a binary representation
            </summary>
            <param name="reader">The binary reader to read from</param>
        </member>
        <member name="T:Hime.Redist.Parsers.RNGLRAutomaton">
            <summary>
            Represents the RNGLR parsing table and productions
            </summary>
            <remarks>
            Binary data of a RNGLR parser
            --- header
            uint16: index of the axiom's variable
            uint16: number of columns
            uint16: number of states
            uint32: number of actions
            uint16: number of productions
            uint16: number of null productions
            --- parse table columns
            uint16: sid of the column
            --- parse table
            See RNGLRTable
            --- action table
            See LRActions
            --- productions table
            See LRProduction
            --- null production table
            indices of the null productions
            </remarks>
        </member>
        <member name="T:Hime.Redist.Parsers.RNGLRAutomaton.Cell">
            <summary>
            Represents a cell in a RNGLR parse table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.Cell.count">
            <summary>
            The number of actions in this cell
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.Cell.index">
            <summary>
            Index of the cell's data
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.RNGLRAutomaton.Cell.ActionsCount">
            <summary>
            Gets the number of actions in the cell
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.RNGLRAutomaton.Cell.ActionsIndex">
            <summary>
            Gets the index of the first action in the Actions table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.axiom">
            <summary>
            Index of the axiom variable
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.ncols">
            <summary>
            The number of columns in the LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.nstates">
            <summary>
            The number of states in the automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.columns">
            <summary>
            Map of symbol ID to column index in the LR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.contexts">
            <summary>
            The contexts information
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.table">
            <summary>
            The RNGLR table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.actions">
            <summary>
            The action table
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.productions">
            <summary>
            The table of LR productions
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRAutomaton.nullables">
            <summary>
            The table of nullable variables
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.RNGLRAutomaton.Axiom">
            <summary>
            Gets the index of the axiom
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.RNGLRAutomaton.StatesCount">
            <summary>
            Gets the number of states in the RNGLR table
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new automaton from the given binary stream
            </summary>
            <param name="reader">The binary stream to load from</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.Find(System.Type,System.String)">
            <summary>
            Loads an automaton from a resource
            </summary>
            <param name="type">The lexer's type</param>
            <param name="resource">The name of the resource containing the lexer</param>
            <returns>The automaton</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetContexts(System.Int32)">
            <summary>
            Gets the contexts opened by the specified state
            </summary>
            <param name="state">State in the LR(k) automaton</param>
            <returns>The opened contexts</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetActionsCount(System.Int32,System.Int32)">
            <summary>
            Gets the number of GLR actions for the given state and sid
            </summary>
            <param name="state">An automaton's state</param>
            <param name="sid">A symbol ID</param>
            <returns>The number of GLR actions</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetAction(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the i-th GLR action for the given state and sid
            </summary>
            <param name="state">An automaton's state</param>
            <param name="sid">A symbol ID</param>
            <param name="index">The action index</param>
            <returns>The GLR action</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetProduction(System.Int32)">
            <summary>
            Gets the production at the given index
            </summary>
            <param name="index">Production's index</param>
            <returns>The production a the given index</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetNullableProduction(System.Int32)">
            <summary>
            Gets the production for the nullable variable with the given index
            </summary>
            <param name="index">Index of a nullable variable</param>
            <returns>The production, or <c>null</c> if the variable is not nullable</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.IsAcceptingState(System.Int32)">
            <summary>
            Determine whether the given state is the accepting state
            </summary>
            <param name="state">An automaton's state</param>
            <returns>True if the state is the accepting state, false otherwise</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRAutomaton.GetExpected(System.Int32,Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Gets the expected terminals for the specified state
            </summary>
            <param name="state">The DFA state</param>
            <param name="terminals">The possible terminals</param>
            <returns>The expected terminals</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.RNGLRParser">
            <summary>
            Represents a base for all RNGLR parsers
            </summary>
        </member>
        <member name="T:Hime.Redist.Parsers.RNGLRParser.Reduction">
            <summary>
            Represents a reduction operation to be performed
            </summary>
            <remarks>
            For reduction of length 0, the node is the GSS node on which it is applied, the first label then is epsilon
            For others, the node is the SECOND GSS node on the path, not the head. The first label is then the label on the transition from the head
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.Reduction.node">
            <summary>
            The GSS node to reduce from
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.Reduction.prod">
            <summary>
            The LR production for the reduction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.Reduction.first">
            <summary>
            The first label in the GSS
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.Reduction.#ctor(System.Int32,Hime.Redist.Parsers.LRProduction,System.Int32)">
            <summary>
            Initializes this operation
            </summary>
            <param name="node">The GSS node to reduce from</param>
            <param name="prod">The LR production for the reduction</param>
            <param name="first">The first label in the GSS</param>
        </member>
        <member name="T:Hime.Redist.Parsers.RNGLRParser.Shift">
            <summary>
            Represents a shift operation to be performed
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.Shift.from">
            <summary>
            GSS node to shift from
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.Shift.to">
            <summary>
            The target RNGLR state
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.Shift.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes this operation
            </summary>
            <param name="from">The GSS node to shift from</param>
            <param name="to">The target RNGLR state</param>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.parserAutomaton">
            <summary>
            The parser automaton
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.gss">
            <summary>
            The GSS for this parser
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.sppf">
            <summary>
            The SPPF being built
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.nullables">
            <summary>
            The sub-trees for the constant nullable variables
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.nextToken">
            <summary>
            The next token
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.reductions">
            <summary>
            The queue of reduction operations
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.RNGLRParser.shifts">
            <summary>
            The queue of shift operations
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.#ctor(Hime.Redist.Parsers.RNGLRAutomaton,Hime.Redist.Symbol[],Hime.Redist.Symbol[],Hime.Redist.SemanticAction[],Hime.Redist.Lexer.BaseLexer)">
            <summary>
            Initializes a new instance of the LRkParser class with the given lexer
            </summary>
            <param name="automaton">The parser's automaton</param>
            <param name="variables">The parser's variables</param>
            <param name="virtuals">The parser's virtuals</param>
            <param name="actions">The parser's actions</param>
            <param name="lexer">The input lexer</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.GetContextPriority(System.Int32,System.Int32)">
            <summary>
            Gets the priority of the specified context required by the specified terminal
            The priority is a positive integer. The lesser the value the higher the priority.
            A value of -1 represents the unavailability of the required context.
            </summary>
            <param name="context">A context</param>
            <param name="onTerminalID">The identifier of the terminal requiring the context</param>
            <returns>The context priority, or -1 if the context is unavailable</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.BuildNullables(System.Int32)">
            <summary>
            Builds the constant sub-trees of nullable variables
            </summary>
            <param name="varCount">The total number of variables</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.BuildNullableDependencies(System.Int32)">
            <summary>
            Builds the dependency table between nullable variables
            </summary>
            <param name="varCount">The total number of variables</param>
            <returns>The dependency table</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.GetNullableDependencies(Hime.Redist.Parsers.LRProduction)">
            <summary>
            Gets the dependencies on nullable variables
            </summary>
            <param name="production">The production of a nullable variable</param>
            <returns>The list of the nullable variables' indices that this production depends on</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.OnUnexpectedToken(System.Int32)">
            <summary>
            Raises an error on an unexepcted token
            </summary>
            <param name="stem">The size of the generation's stem</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.CheckIsExpected(System.Int32,Hime.Redist.Symbol)">
            <summary>
            Checks whether the specified terminal is indeed expected for a reduction
            </summary>
            <param name="gssNode">The GSS node from which to reduce</param>
            <param name="terminal">The terminal to check</param>
            <returns><code>true</code> if the terminal is really expected</returns>
            <remarks>
            This check is required because in the case of a base LALR graph,
            some terminals expected for reduction in the automaton are coming from other paths.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.BuildSPPF(System.Int32,Hime.Redist.Parsers.LRProduction,System.Int32,Hime.Redist.Parsers.GSSPath)">
            <summary>
            Builds the SPPF
            </summary>
            <param name="generation">The current GSS generation</param>
            <param name="production">The LR production</param>
            <param name="first">The first label of the path</param>
            <param name="path">The reduction path</param>
            <returns>The identifier of the corresponding SPPF node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.Parse">
            <summary>
            Parses the input and returns the produced AST
            </summary>
            <returns>AST produced by the parser representing the input, or null if unrecoverable errors were encountered</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.Reducer(System.Int32)">
            <summary>
            Executes the reduction operations from the given GSS generation
            </summary>
            <param name="generation">The current GSS generation</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.ExecuteReduction(System.Int32,Hime.Redist.Parsers.RNGLRParser.Reduction)">
            <summary>
            Executes a reduction operation for all found path
            </summary>
            <param name="generation">The current GSS generation</param>
            <param name="reduction">The reduction operation</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.ExecuteReduction(System.Int32,Hime.Redist.Parsers.RNGLRParser.Reduction,Hime.Redist.Parsers.GSSPath)">
            <summary>
            Executes a reduction operation for a given path
            </summary>
            <param name="generation">The current GSS generation</param>
            <param name="reduction">The reduction operation</param>
            <param name="path">The GSS path to use for the reduction</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.Shifter(Hime.Redist.Lexer.TokenKernel)">
            <summary>
            Executes the shift operations for the given token
            </summary>
            <param name="oldtoken">A token</param>
            <returns>The next generation</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.ExecuteShift(System.Int32,System.Int32,Hime.Redist.Parsers.RNGLRParser.Shift)">
            <summary>
            Executes a shift operation
            </summary>
            <param name="gen">The GSS generation to start from</param>
            <param name="label">The GSS label to use for the new GSS edges</param>
            <param name="shift">The shift operation</param>
        </member>
        <member name="M:Hime.Redist.Parsers.RNGLRParser.GetNextByVar(System.Int32,System.Int32)">
            <summary>
            Gets the next RNGLR state by a shift with the given variable ID
            </summary>
            <param name="state">A RNGLR state</param>
            <param name="var">A variable ID</param>
            <returns>The next RNGLR state, or 0xFFFF if no transition is found</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPF">
            <summary>
            Represents a Shared-Packed Parse Forest
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPF.EPSILON">
            <summary>
            Represents the epsilon node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPF.nodes">
            <summary>
            The nodes in the SPPF
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPF.#ctor">
            <summary>
            Initializes this SPPF
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPF.GetNode(System.Int32)">
            <summary>
            Gets the SPPF node for the specified identifier
            </summary>
            <param name="identifier">The identifier of an SPPF node</param>
            <returns>The SPPF node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPF.NewNode(Hime.Redist.TableElemRef)">
            <summary>
            Creates a new single node in the SPPF
            </summary>
            <param name="label">The original label for this node</param>
            <returns>The identifier of the new node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPF.NewNode(Hime.Redist.TableElemRef,Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],System.Int32)">
            <summary>
            Creates a new single node in the SPPF
            </summary>
            <param name="original">The original symbol of this node</param>
            <param name="label">The label on the first version of this node</param>
            <param name="childrenBuffer">A buffer for the children</param>
            <param name="childrenCount">The number of children</param>
            <returns>The identifier of the new node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPF.NewReplaceableNode(Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],Hime.Redist.TreeAction[],System.Int32)">
            <summary>
            Creates a new replaceable node in the SPPF
            </summary>
            <param name="label">The label of this node</param>
            <param name="childrenBuffer">A buffer for the children</param>
            <param name="actionsBuffer">A buffer for the actions on the children</param>
            <param name="childrenCount">The number of children</param>
            <returns>The identifier of the new node</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFBuilder">
            <summary>
            Represents a structure that helps build a Shared Packed Parse Forest (SPPF)
            </summary>
            <remarks>
            A SPPF is a compact representation of multiple variants of an AST at once.
            GLR algorithms originally builds the complete SPPF.
            However we only need to build one of the variant, i.e. an AST for the user.
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.INIT_HANDLE_SIZE">
            <summary>
            The initial size of the reduction handle
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.INIT_HISTORY_SIZE">
            <summary>
            The initial size of the history buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.INIT_HISTORY_PART_SIZE">
            <summary>
            The initial size of the history parts' buffers
            </summary>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFBuilder.HistoryPart">
            <summary>
            Represents a generation of GSS edges in the current history
            The history is used to quickly find pre-existing matching GSS edges
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.HistoryPart.data">
            <summary>
            The GSS labels in this part
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.HistoryPart.generation">
            <summary>
            The index of the represented GSS generation
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.HistoryPart.next">
            <summary>
            The next available slot in the data
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.HistoryPart.#ctor">
            <summary>
            Initializes a new instance
            </summary>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFBuilder.HistoryPartFactory">
            <summary>
            Represents a factory of history parts
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.HistoryPartFactory.CreateNew(Hime.Redist.Utils.Pool{Hime.Redist.Parsers.SPPFBuilder.HistoryPart})">
            <summary>
             Creates a new object
            </summary>
            <param name="pool">The enclosing pool</param>
            <returns>The created object</returns>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.poolHPs">
            <summary>
            The pool of history parts
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.history">
            <summary>
            The history
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.nextHP">
            <summary>
            The next available slot for a history part
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.sppf">
            <summary>
            The SPPF being built
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.cacheChildren">
            <summary>
            The adjacency cache for the reduction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.cacheNext">
            <summary>
            The new available slot in the current cache
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.handleIndices">
            <summary>
            The reduction handle represented as the indices of the sub-trees in the cache
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.handleActions">
            <summary>
            The actions for the reduction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.handleNext">
            <summary>
            The index of the next available slot in the handle
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.stack">
            <summary>
            The stack of semantic objects for the reduction
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.popCount">
            <summary>
            The number of items popped from the stack
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFBuilder.result">
            <summary>
            The AST being built
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFBuilder.Item(System.Int32)">
            <summary>
            Gets the symbol at the i-th index
            </summary>
            <param name="index">Index of the symbol</param>
            <returns>The symbol at the given index</returns>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFBuilder.Length">
            <summary>
            Gets the length of this body
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.#ctor(Hime.Redist.TokenRepository,Hime.Redist.Utils.ROList{Hime.Redist.Symbol},Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Initializes this SPPF
            </summary>
            <param name="tokens">The token table</param>
            <param name="variables">The table of parser variables</param>
            <param name="virtuals">The table of parser virtuals</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.GetHistoryPart(System.Int32)">
            <summary>
            Gets the history part for the given GSS generation
            </summary>
            <param name="generation">The index of a GSS generation</param>
            <returns>The corresponding history part, or <c>null</c></returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ClearHistory">
            <summary>
            Clears the current history
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.GetSymbolOn(System.Int32)">
            <summary>
            Gets the symbol on the specified GSS edge label
            </summary>
            <param name="label">The label of a GSS edge</param>
            <returns>The symbol on the edge</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.GetLabelFor(System.Int32,Hime.Redist.TableElemRef)">
            <summary>
            Gets the GSS label already in history for the given GSS generation and symbol
            </summary>
            <param name="generation">The index of a GSS generation</param>
            <param name="symbol">A symbol to look for</param>
            <returns>The existing GSS label, or the epsilon label</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.GetSingleNode(Hime.Redist.TableElemRef)">
            <summary>
            Creates a single node in the result SPPF an returns it
            </summary>
            <param name="symbol">The symbol as the node's label</param>
            <returns>The created node's index in the SPPF</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReductionPrepare(System.Int32,Hime.Redist.Parsers.GSSPath,System.Int32)">
            <summary>
            Prepares for the forthcoming reduction operations
            </summary>
            <param name="first">The first label</param>
            <param name="path">The path being reduced</param>
            <param name="length">The reduction length</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReductionPop(Hime.Redist.TreeAction)">
            <summary>
            During a reduction, pops the top symbol from the stack and gives it a tree action
            </summary>
            <param name="action">The tree action to apply to the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.AddToCache(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            Adds the specified GSS label to the reduction cache with the given tree action
            </summary>
            <param name="gssLabel">The label to add to the cache</param>
            <param name="action">The tree action to apply</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.AddToCache(Hime.Redist.Parsers.SPPFNodeNormal,Hime.Redist.TreeAction)">
            <summary>
            Adds the specified SPPF node to the cache
            </summary>
            <param name="node">The node to add to the cache</param>
            <param name="action">The tree action to apply onto the node</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReductionAddVirtual(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            During a reduction, inserts a virtual symbol
            </summary>
            <param name="index">The virtual symbol's index</param>
            <param name="action">The tree action applied onto the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReductionAddNullable(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            During a reduction, inserts the sub-tree of a nullable variable
            </summary>
            <param name="nullable">The sub-tree of a nullable variable</param>
            <param name="action">The tree action applied onto the symbol</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.Reduce(System.Int32,System.Int32,Hime.Redist.TreeAction)">
            <summary>
            Finalizes the reduction operation
            </summary>
            <param name="generation">The generation to reduce from</param>
            <param name="varIndex">The reduced variable index</param>
            <param name="headAction">The tree action applied in the rule's head</param>
            <returns>The identifier of the produced SPPF node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReduceNormal(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            Executes the reduction as a normal reduction
            </summary>
            <param name="varIndex">The reduced variable index</param>
            <param name="headAction">The tree action applied in the rule's head</param>
            <returns>The identifier of the produced SPPF node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.ReduceReplaceable(System.Int32)">
            <summary>
            Executes the reduction as the reduction of a replaceable variable
            </summary>
            <param name="varIndex">The reduced variable index</param>
            <returns>The identifier of the produced SPPF node</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.AddToHistory(System.Int32,System.Int32)">
            <summary>
            Adds the specified GSS label to the current history
            </summary>
            <param name="generation">The current generation</param>
            <param name="label">The label identifier of the SPPF node to use as a GSS label</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.GetTree(System.Int32)">
            <summary>
            Finalizes the parse tree and returns it
            </summary>
            <param name="root">The identifier of the SPPF node that serves as root</param>
            <returns>The final parse tree</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFBuilder.BuildFinalAST(Hime.Redist.Parsers.SPPFNodeRef)">
            <summary>
            Builds the final AST for the specified SPPF node reference
            </summary>
            <param name="reference">A reference to an SPPF node in a specific version</param>
            <returns>The AST node for the SPPF reference</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFNode">
            <summary>
            Represents a node in a Shared-Packed Parse Forest
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNode.identifier">
            <summary>
            The identifier of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNode.Identifier">
            <summary>
            Gets the identifier of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNode.IsReplaceable">
            <summary>
            Gets whether this node must be replaced by its children
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNode.OriginalSymbol">
            <summary>
            Gets the original symbol for this node
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNode.#ctor(System.Int32)">
            <summary>
            Initializes this node
            </summary>
            <param name="identifier">The identifier of this node</param>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFNodeNormal">
            <summary>
            Represents a node in a Shared-Packed Parse Forest
            A node can have multiple versions
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeNormal.VERSION_COUNT">
            <summary>
            The size of the version buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeNormal.original">
            <summary>
            The label of this node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeNormal.versions">
            <summary>
            The different versions of this node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeNormal.versionsCount">
            <summary>
            The number of versions of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeNormal.IsReplaceable">
            <summary>
            Gets whether this node must be replaced by its children
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeNormal.OriginalSymbol">
            <summary>
            Gets the original symbol for this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeNormal.DefaultVersion">
            <summary>
            Gets the default version of this node
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeNormal.GetVersion(System.Int32)">
            <summary>
            Gets a specific version of this node
            </summary>
            <param name="version">The version number</param>
            <returns>The requested version</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeNormal.#ctor(System.Int32,Hime.Redist.TableElemRef)">
            <summary>
            Initializes this node
            </summary>
            <param name="identifier">The identifier of this node</param>
            <param name="label">The label of this node</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeNormal.#ctor(System.Int32,Hime.Redist.TableElemRef,Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],System.Int32)">
            <summary>
            Initializes this node
            </summary>
            <param name="identifier">The identifier of this node</param>
            <param name="original">The original symbol of this node</param>
            <param name="label">The label on the first version of this node</param>
            <param name="childrenBuffer">A buffer for the children</param>
            <param name="childrenCount">The number of children</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeNormal.NewVersion(Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],System.Int32)">
            <summary>
            Adds a new version to this node
            </summary>
            <param name="label">The label for this version of the node</param>
            <param name="children">A buffer of children for this version of the node</param>
            <param name="childrenCount">The number of children</param>
            <returns>The reference to this new version</returns>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFNodeRef">
            <summary>
            Represents a reference to a Shared-Packed Parse Forest node in a specific version
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeRef.nodeId">
            <summary>
            The identifier of the node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeRef.version">
            <summary>
            The version to refer to
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeRef.NodeId">
            <summary>
            Gets the identifier of the node referred to
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeRef.Version">
            <summary>
            Gets the version of the node referred to
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeRef.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes this reference
            </summary>
            <param name="nodeId">The identifier of the node to refer to</param>
            <param name="version">The version of the node to refer to</param>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFNodeReplaceable">
            <summary>
            Represents a node in a Shared-Packed Parse Forest that can be replaced by its children
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeReplaceable.label">
            <summary>
            The label of this node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeReplaceable.children">
            <summary>
            The children of this node
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeReplaceable.actions">
            <summary>
            The tree actions on the children of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeReplaceable.IsReplaceable">
            <summary>
            Gets whether this node must be replaced by its children
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeReplaceable.OriginalSymbol">
            <summary>
            Gets the original symbol for this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeReplaceable.ChildrenCount">
            <summary>
            Gets the number of children of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeReplaceable.Children">
            <summary>
            Gets the children of this node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeReplaceable.Actions">
            <summary>
            Gets the tree actions on the children of this node
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeReplaceable.#ctor(System.Int32,Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],Hime.Redist.TreeAction[],System.Int32)">
            <summary>
            Initializes this node
            </summary>
            <param name="identifier">The identifier of this node</param>
            <param name="label">The label of this node</param>
            <param name="childrenBuffer">A buffer for the children</param>
            <param name="actionsBuffer">A buffer for the actions on the children</param>
            <param name="childrenCount">The number of children</param>
        </member>
        <member name="T:Hime.Redist.Parsers.SPPFNodeVersion">
            <summary>
            Represents a version of a node in a Shared-Packed Parse Forest
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeVersion.label">
            <summary>
            The label of the node for this version
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SPPFNodeVersion.children">
            <summary>
            The children of the node for this version
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeVersion.Label">
            <summary>
            Gets the label of the node for this version
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeVersion.ChildrenCount">
            <summary>
            Gets the number of children for this version of the node
            </summary>
        </member>
        <member name="P:Hime.Redist.Parsers.SPPFNodeVersion.Children">
            <summary>
            Gets the children of the node for this version
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeVersion.#ctor(Hime.Redist.TableElemRef)">
            <summary>
            Initializes this node version without children
            </summary>
            <param name="label">The label for this version of the node</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SPPFNodeVersion.#ctor(Hime.Redist.TableElemRef,Hime.Redist.Parsers.SPPFNodeRef[],System.Int32)">
            <summary>
            Initializes this node version
            </summary>
            <param name="label">The label for this version of the node</param>
            <param name="children">A buffer of children for this version of the node</param>
            <param name="childrenCount">The number of children</param>
        </member>
        <member name="T:Hime.Redist.Parsers.SubTree">
            <summary>
            Represents a sub-tree in an AST
            </summary>
            <remarks>
            A sub-tree is composed of a root with its children.
            The children may also have children.
            The maximum depth of a sub-tree is 2 (root, children and children's children), in which case the root is always a replaceable node.
            The internal representation of a sub-tree is based on arrays.
            The organization is that a node's children are immediately following it in the array.
            For example, the tree A(B(CD)E(FG)) is represented as [ABCDEFG].
            </remarks>
        </member>
        <member name="F:Hime.Redist.Parsers.SubTree.pool">
            <summary>
            The pool containing this object
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SubTree.nodes">
            <summary>
            The nodes in this buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SubTree.actions">
            <summary>
            The tree actions for the nodes
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.GetLabelAt(System.Int32)">
            <summary>
            Gets the label of the node at the given index
            </summary>
            <param name="index">The index within the buffer</param>
            <returns>The label in the buffer</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.GetActionAt(System.Int32)">
            <summary>
            Gets the tree action applied onto the node at the given index
            </summary>
            <param name="index">The index within the buffer</param>
            <returns>The tree action in the buffer</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.SetActionAt(System.Int32,Hime.Redist.TreeAction)">
            <summary>
            Sets the tree action applied onto the node at the given index
            </summary>
            <param name="index">The index within the buffer</param>
            <param name="action">The tree action to apply</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.GetChildrenCountAt(System.Int32)">
            <summary>
            Gets the number of children of the node at the given index
            </summary>
            <param name="index">The index within the buffer</param>
            <returns>The number of children</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.SetChildrenCountAt(System.Int32,System.Int32)">
            <summary>
            Sets the number of children of the node at the given index
            </summary>
            <param name="index">The index within the buffer</param>
            <param name="count">The number of children</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.GetSize">
            <summary>
            Gets the total number of nodes in this sub-tree
            </summary>
            <returns>The total number of nodes in this sub-tree</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.#ctor(Hime.Redist.Utils.Pool{Hime.Redist.Parsers.SubTree},System.Int32)">
            <summary>
            Instantiates a new sub-tree attached to the given pool, with the given capacity
            </summary>
            <param name="pool">The pool to which this sub-tree is attached</param>
            <param name="capacity">The capacity of the internal buffer of this sub-tree</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.Clone">
            <summary>
            Clones this sub-tree
            </summary>
            <returns>The clone</returns>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.SetupRoot(Hime.Redist.TableElemRef,Hime.Redist.TreeAction)">
            <summary>
            Initializes the root of this sub-tree
            </summary>
            <param name="symbol">The root's symbol</param>
            <param name="action">The tree action applied on the root</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.CopyTo(Hime.Redist.Parsers.SubTree,System.Int32)">
            <summary>
            Copy the content of this sub-tree to the given sub-tree's buffer beginning at the given index
            </summary>
            <param name="destination">The sub-tree to copy to</param>
            <param name="index">The starting index in the destination's buffer</param>
            <remarks>
            This methods only applies in the case of a depth 1 sub-tree (only a root and its children).
            The results of this method in the case of a depth 2 sub-tree is undetermined.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.CopyChildrenTo(Hime.Redist.Parsers.SubTree,System.Int32)">
            <summary>
            Copy the root's children of this sub-tree to the given sub-tree's buffer beginning at the given index
            </summary>
            <param name="destination">The sub-tree to copy to</param>
            <param name="index">The starting index in the destination's buffer</param>
            <remarks>
            This methods only applies in the case of a depth 1 sub-tree (only a root and its children).
            The results of this method in the case of a depth 2 sub-tree is undetermined.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.CommitChildrenOf(System.Int32,Hime.Redist.AST)">
            <summary>
            Commits the children of a sub-tree in this buffer to the final ast
            </summary>
            <param name="index">The starting index of the sub-tree</param>
            <param name="ast">The ast to commit to</param>
            <remarks>
            If the index is 0, the root's children are committed, assuming this is a depth-1 sub-tree.
            If not, the children of the child at the given index are committed.
            </remarks>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.Commit(Hime.Redist.AST)">
            <summary>
            Commits this buffer to the final ast
            </summary>
            <param name="ast">The ast to commit to</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.SetAt(System.Int32,Hime.Redist.TableElemRef,Hime.Redist.TreeAction)">
            <summary>
            Sets the content of the i-th item
            </summary>
            <param name="index">The index of the item to set</param>
            <param name="symbol">The symbol</param>
            <param name="action">The tree action</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.Move(System.Int32,System.Int32)">
            <summary>
            Moves an item within the buffer
            </summary>
            <param name="from">The index of the item to move</param>
            <param name="to">The destination index for the item</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.MoveRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves a range of items within the buffer
            </summary>
            <param name="from">The starting index of the items to move</param>
            <param name="to">The destination index for the items</param>
            <param name="length">The number of items to move</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTree.Free">
            <summary>
            Releases this sub-tree to the pool
            </summary>
        </member>
        <member name="T:Hime.Redist.Parsers.SubTreeFactory">
            <summary>
            Represents of factory of sub-trees that have a specified capacity
            </summary>
        </member>
        <member name="F:Hime.Redist.Parsers.SubTreeFactory.capacity">
            <summary>
            The capacity of the SubTrees produced by this factory
            </summary>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTreeFactory.#ctor(System.Int32)">
            <summary>
            Initializes this SubTree factory
            </summary>
            <param name="capacity">The capacity of the produced SubTrees</param>
        </member>
        <member name="M:Hime.Redist.Parsers.SubTreeFactory.CreateNew(Hime.Redist.Utils.Pool{Hime.Redist.Parsers.SubTree})">
            <summary>
             Creates a new object
            </summary>
            <param name="pool">The enclosing pool</param>
            <returns>The created object</returns>
        </member>
        <member name="T:Hime.Redist.SemanticAction">
            <summary>
            Delegate for a user-defined semantic action
            </summary>
            <param name="head">The grammar variable representing the head of the reduced rule</param>
            <param name="body">The current body at the time of the action</param>
        </member>
        <member name="T:Hime.Redist.SemanticBody">
            <summary>
            Represents the semantic body of a rule being reduced
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticBody.Item(System.Int32)">
            <summary>
            Gets the element at the i-th index
            </summary>
            <param name="index">Index of the element</param>
            <returns>The element at the given index</returns>
        </member>
        <member name="P:Hime.Redist.SemanticBody.Length">
            <summary>
            Gets the length of this body
            </summary>
        </member>
        <member name="T:Hime.Redist.SemanticElement">
            <summary>
            Represents an element of parsing data
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.SymbolType">
            <summary>
            Gets the type of symbol this element represents
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.Position">
            <summary>
            Gets the position in the input text of this element
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.Span">
            <summary>
            Gets the span in the input text of this element
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.Context">
            <summary>
            Gets the context of this element in the input
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.Symbol">
            <summary>
            Gets the grammar symbol associated to this element
            </summary>
        </member>
        <member name="P:Hime.Redist.SemanticElement.Value">
            <summary>
            Gets the value of this element, if any
            </summary>
        </member>
        <member name="T:Hime.Redist.Symbol">
            <summary>
            Represents a grammar symbol (terminal, variable or virtual)
            </summary>
        </member>
        <member name="F:Hime.Redist.Symbol.SID_NOTHING">
            <summary>
            Symbol ID for inexistant symbol
            </summary>
        </member>
        <member name="F:Hime.Redist.Symbol.SID_EPSILON">
            <summary>
            Symbol ID of the Epsilon terminal
            </summary>
        </member>
        <member name="F:Hime.Redist.Symbol.SID_DOLLAR">
            <summary>
            Symbol ID of the Dollar terminal
            </summary>
        </member>
        <member name="F:Hime.Redist.Symbol.id">
            <summary>
            The symbol's unique identifier
            </summary>
        </member>
        <member name="F:Hime.Redist.Symbol.name">
            <summary>
            The symbol's name
            </summary>
        </member>
        <member name="P:Hime.Redist.Symbol.ID">
            <summary>
            Gets the symbol's unique identifier
            </summary>
        </member>
        <member name="P:Hime.Redist.Symbol.Name">
            <summary>
            Gets the symbol's name
            </summary>
        </member>
        <member name="M:Hime.Redist.Symbol.#ctor(System.Int32,System.String)">
            <summary>
            Initializes this symbol
            </summary>
            <param name="id">The id</param>
            <param name="name">The symbol's name</param>
        </member>
        <member name="M:Hime.Redist.Symbol.ToString">
            <summary>
            Gets a string representation of this symbol
            </summary>
            <returns>The value of this symbol</returns>
        </member>
        <member name="T:Hime.Redist.SymbolType">
            <summary>
            The possible types of symbol
            </summary>
        </member>
        <member name="F:Hime.Redist.SymbolType.Terminal">
            <summary>
            A terminal symbol, defined in the original grammar
            </summary>
        </member>
        <member name="F:Hime.Redist.SymbolType.Variable">
            <summary>
            A variable symbol, defined in the original grammar
            </summary>
        </member>
        <member name="F:Hime.Redist.SymbolType.Virtual">
            <summary>
            A virtual symbol, defined in the original grammar
            </summary>
        </member>
        <member name="T:Hime.Redist.TableElemRef">
            <summary>
            Represents a compact reference to an element in a table
            </summary>
        </member>
        <member name="F:Hime.Redist.TableElemRef.data">
            <summary>
            The backend data
            </summary>
        </member>
        <member name="P:Hime.Redist.TableElemRef.Type">
            <summary>
            Gets the element's type
            </summary>
        </member>
        <member name="P:Hime.Redist.TableElemRef.Index">
            <summary>
            Gets the element's index in its respective table
            </summary>
        </member>
        <member name="M:Hime.Redist.TableElemRef.#ctor(Hime.Redist.TableType,System.Int32)">
            <summary>
            Initializes this reference
            </summary>
            <param name="type">The element's type</param>
            <param name="index">The element's index in its table</param>
        </member>
        <member name="M:Hime.Redist.TableElemRef.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:Hime.Redist.TableElemRef"/> object.
            </summary>
            <returns>
            A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a hash table.
            </returns>
        </member>
        <member name="M:Hime.Redist.TableElemRef.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Hime.Redist.TableElemRef"/>.
            </summary>
            <param name='obj'>
            The <see cref="T:System.Object"/> to compare with the current <see cref="T:Hime.Redist.TableElemRef"/>.
            </param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:Hime.Redist.TableElemRef"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Hime.Redist.TableType">
            <summary>
            Represents a type of table
            </summary>
        </member>
        <member name="F:Hime.Redist.TableType.None">
            <summary>
            Marks as other (used for SPPF nodes)
            </summary>
        </member>
        <member name="F:Hime.Redist.TableType.Token">
            <summary>
            Table of tokens
            </summary>
        </member>
        <member name="F:Hime.Redist.TableType.Variable">
            <summary>
            Table of variables
            </summary>
        </member>
        <member name="F:Hime.Redist.TableType.Virtual">
            <summary>
            Tables of virtuals
            </summary>
        </member>
        <member name="T:Hime.Redist.Text">
            <summary>
            Represents the input of parser with some metadata for line endings
            </summary>
            <remarks>
            All line numbers and column numbers are 1-based.
            Indices in the content are 0-based.
            </remarks>
        </member>
        <member name="P:Hime.Redist.Text.LineCount">
            <summary>
            Gets the number of lines
            </summary>
        </member>
        <member name="P:Hime.Redist.Text.Size">
            <summary>
            Gets the size in number of characters
            </summary>
        </member>
        <member name="M:Hime.Redist.Text.GetValue(System.Int32,System.Int32)">
            <summary>
            Gets the substring beginning at the given index with the given length
            </summary>
            <param name="index">Index of the substring from the start</param>
            <param name="length">Length of the substring</param>
            <returns>The substring</returns>
        </member>
        <member name="M:Hime.Redist.Text.GetValue(Hime.Redist.TextSpan)">
            <summary>
            Get the substring corresponding to the specified span
            </summary>
            <param name="span">A span in this text</param>
            <returns>The substring</returns>
        </member>
        <member name="M:Hime.Redist.Text.GetLineIndex(System.Int32)">
            <summary>
            Gets the starting index of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The starting index of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="M:Hime.Redist.Text.GetLineLength(System.Int32)">
            <summary>
            Gets the length of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The length of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="M:Hime.Redist.Text.GetLineContent(System.Int32)">
            <summary>
            Gets the string content of the i-th line
            </summary>
            <param name="line">The line number</param>
            <returns>The string content of the line</returns>
            <remarks>The line numbering is 1-based</remarks>
        </member>
        <member name="M:Hime.Redist.Text.GetPositionAt(System.Int32)">
            <summary>
            Gets the position at the given index
            </summary>
            <param name="index">Index from the start</param>
            <returns>The position (line and column) at the index</returns>
        </member>
        <member name="M:Hime.Redist.Text.GetContext(Hime.Redist.TextPosition)">
            <summary>
            Gets the context description for the current text at the specified position
            </summary>
            <param name="position">The position in this text</param>
            <returns>The context description</returns>
        </member>
        <member name="M:Hime.Redist.Text.GetContext(Hime.Redist.TextPosition,System.Int32)">
            <summary>
            Gets the context description for the current text at the specified position
            </summary>
            <param name="position">The position in this text</param>
            <param name="length">The length of the element to contextualize</param>
            <returns>The context description</returns>
        </member>
        <member name="M:Hime.Redist.Text.GetContext(Hime.Redist.TextSpan)">
            <summary>
            Gets the context description for the current text at the specified span
            </summary>
            <param name="span">The span of text to contextualize</param>
            <returns>The context description</returns>
        </member>
        <member name="T:Hime.Redist.TextContext">
            <summary>
            Represents the context description of a position in a piece of text.
            A context is composed of two pieces of text, the line content and the pointer.
            For example, given the piece of text:
            "public Struct Context"
            A context pointing to the second word will look like:
            content = "public Struct Context"
            pointer = "       ^"
            </summary>
        </member>
        <member name="F:Hime.Redist.TextContext.content">
            <summary>
            The text content being represented
            </summary>
        </member>
        <member name="F:Hime.Redist.TextContext.pointer">
            <summary>
            The pointer textual representation
            </summary>
        </member>
        <member name="P:Hime.Redist.TextContext.Content">
            <summary>
            Gets the text content being represented
            </summary>
            <value>The text content being represented</value>
        </member>
        <member name="P:Hime.Redist.TextContext.Pointer">
            <summary>
            Gets the pointer textual representation
            </summary>
            <value>The pointer textual representation</value>
        </member>
        <member name="M:Hime.Redist.TextContext.#ctor(System.String,System.String)">
            <summary>
            Initializes this context
            </summary>
            <param name="content">The text being begin represented</param>
            <param name="pointer">The pointer textual representation</param>
        </member>
        <member name="T:Hime.Redist.TextPosition">
            <summary>
            Represents a position in term of line and column in a text input
            </summary>
        </member>
        <member name="F:Hime.Redist.TextPosition.line">
            <summary>
            The line number
            </summary>
        </member>
        <member name="F:Hime.Redist.TextPosition.column">
            <summary>
            The column number
            </summary>
        </member>
        <member name="P:Hime.Redist.TextPosition.Line">
            <summary>
            Gets the line number
            </summary>
        </member>
        <member name="P:Hime.Redist.TextPosition.Column">
            <summary>
            Gets the column number
            </summary>
        </member>
        <member name="M:Hime.Redist.TextPosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes this position with the given line and column numbers
            </summary>
            <param name="line">The line number</param>
            <param name="column">The column number</param>
        </member>
        <member name="M:Hime.Redist.TextPosition.ToString">
            <summary>
            Gets a string representation of this position
            </summary>
            <returns></returns>
        </member>
        <member name="T:Hime.Redist.TextSpan">
            <summary>
            Represents a span of text in an input as a starting index and length
            </summary>
        </member>
        <member name="F:Hime.Redist.TextSpan.index">
            <summary>
            The starting index
            </summary>
        </member>
        <member name="F:Hime.Redist.TextSpan.length">
            <summary>
            The length
            </summary>
        </member>
        <member name="P:Hime.Redist.TextSpan.Index">
            <summary>
            Gets the starting index of this span
            </summary>
        </member>
        <member name="P:Hime.Redist.TextSpan.Length">
            <summary>
            Gets the length of this span
            </summary>
        </member>
        <member name="M:Hime.Redist.TextSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes this span
            </summary>
            <param name="index">The span's index</param>
            <param name="length">The span's length</param>
        </member>
        <member name="M:Hime.Redist.TextSpan.ToString">
            <summary>
            Gets a string representation of this position
            </summary>
            <returns></returns>
        </member>
        <member name="T:Hime.Redist.Token">
            <summary>
            Represents a token as an output element of a lexer
            </summary>
        </member>
        <member name="F:Hime.Redist.Token.repository">
            <summary>
            The repository containing this token
            </summary>
        </member>
        <member name="F:Hime.Redist.Token.index">
            <summary>
            The index of this token in the text
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.SymbolType">
            <summary>
            Gets the type of symbol this element represents
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.Position">
            <summary>
            Gets the position in the input text of this token
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.Span">
            <summary>
            Gets the span in the input text of this token
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.Context">
            <summary>
            Gets the context of this token in the input
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.Symbol">
            <summary>
            Gets the terminal associated to this token
            </summary>
        </member>
        <member name="P:Hime.Redist.Token.Value">
            <summary>
            Gets the value of this token
            </summary>
        </member>
        <member name="M:Hime.Redist.Token.#ctor(Hime.Redist.TokenRepository,System.Int32)">
            <summary>
            Initializes this token
            </summary>
            <param name="repository">The repository containing the token</param>
            <param name="index">The token's index</param>
        </member>
        <member name="M:Hime.Redist.Token.ToString">
            <summary>
            Gets a string representation of this token
            </summary>
            <returns>The string representation of the token</returns>
        </member>
        <member name="T:Hime.Redist.TokenRepository">
            <summary>
            A repository of matched tokens
            </summary>
        </member>
        <member name="T:Hime.Redist.TokenRepository.Cell">
            <summary>
            Represents the metadata of a token
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.Cell.terminal">
            <summary>
            The terminal's index
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.Cell.span">
            <summary>
            The span of this token
            </summary>
        </member>
        <member name="M:Hime.Redist.TokenRepository.Cell.#ctor(System.Int32,Hime.Redist.TextSpan)">
            <summary>
            Initializes this cell
            </summary>
            <param name="terminal">The terminal's index</param>
            <param name="span">The token's span in the input</param>
        </member>
        <member name="T:Hime.Redist.TokenRepository.LinearEnumerator">
            <summary>
            Represents an iterator over all the tokens in this repository
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.LinearEnumerator.repository">
            <summary>
            The repository
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.LinearEnumerator.current">
            <summary>
            The index of the current token
            </summary>
        </member>
        <member name="M:Hime.Redist.TokenRepository.LinearEnumerator.#ctor(Hime.Redist.TokenRepository)">
            <summary>
            Initializes this iterator
            </summary>
            <param name="repository">The repository</param>
        </member>
        <member name="P:Hime.Redist.TokenRepository.LinearEnumerator.Current">
            <summary>
            Gets the current token
            </summary>
        </member>
        <member name="P:Hime.Redist.TokenRepository.LinearEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current token
            </summary>
        </member>
        <member name="M:Hime.Redist.TokenRepository.LinearEnumerator.MoveNext">
            <summary>
            Moves to the next elmeent
            </summary>
            <returns>true if there is a next element</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.LinearEnumerator.Reset">
            <summary>
            Resets this iterator
            </summary>
        </member>
        <member name="M:Hime.Redist.TokenRepository.LinearEnumerator.Dispose">
            <summary>
            Disposes of this iterator
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.terminals">
            <summary>
            The terminal symbols matched in this content
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.text">
            <summary>
            The base text
            </summary>
        </member>
        <member name="F:Hime.Redist.TokenRepository.cells">
            <summary>
            The token data in this content
            </summary>
        </member>
        <member name="P:Hime.Redist.TokenRepository.Size">
            <summary>
            Gets the number of tokens in this repository
            </summary>
        </member>
        <member name="P:Hime.Redist.TokenRepository.Item(System.Int32)">
            <summary>
            Gets the token at the specified index
            </summary>
            <param name="index">An index in this repository</param>
            <returns>The token at the specified index</returns>
        </member>
        <member name="P:Hime.Redist.TokenRepository.Terminals">
            <summary>
            Gets the terminal symbols matched in this content
            </summary>
        </member>
        <member name="M:Hime.Redist.TokenRepository.#ctor(Hime.Redist.Utils.ROList{Hime.Redist.Symbol},Hime.Redist.Text)">
            <summary>
            Initializes this text
            </summary>
            <param name="terminals">The terminal symbols</param>
            <param name="text">The base text</param>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetPosition(System.Int32)">
            <summary>
            Gets the position in the input text of the given token
            </summary>
            <param name="index">A token's index</param>
            <returns>The position in the text</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetSpan(System.Int32)">
            <summary>
            Gets the span in the input text of the given token
            </summary>
            <param name="token">A token's index</param>
            <returns>The span in the text</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetContext(System.Int32)">
            <summary>
            Gets the context in the input of the given token
            </summary>
            <param name="index">A token's index</param>
            <returns>The context</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetSymbol(System.Int32)">
            <summary>
            Gets the grammar symbol associated to the given token
            </summary>
            <param name="index">A token's index</param>
            <returns>The associated symbol</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetValue(System.Int32)">
            <summary>
            Gets the value of the given token
            </summary>
            <param name="index">A token's index</param>
            <returns>The associated value</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.FindTokenAt(System.Int32)">
            <summary>
            Gets the token (if any) that contains the specified index in the input text
            </summary>
            <param name="index">An index within the input text</param>
            <returns>The token, if any</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.GetEnumerator">
            <summary>
            Gets an enumerator of the tokens in this repository
            </summary>
            <returns>An enumerator of the tokens in this repository</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator of the tokens in this repository
            </summary>
            <returns>An enumerator of the tokens in this repository</returns>
        </member>
        <member name="M:Hime.Redist.TokenRepository.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Registers a new token in this repository
            </summary>
            <param name="terminal">The index of the matched terminal</param>
            <param name="index">The starting index of the matched value in the input</param>
            <param name="length">The length of the matched value in the input</param>
            <returns>The index of the added token</returns>
        </member>
        <member name="T:Hime.Redist.TreeAction">
            <summary>
            Represents a tree action for an AST node
            </summary>
        </member>
        <member name="F:Hime.Redist.TreeAction.None">
            <summary>
            Keep the node as is
            </summary>
        </member>
        <member name="F:Hime.Redist.TreeAction.ReplaceByChildren">
            <summary>
            Replace the node by its children
            </summary>
        </member>
        <member name="F:Hime.Redist.TreeAction.Drop">
            <summary>
            Drop the node and all its descendants
            </summary>
        </member>
        <member name="F:Hime.Redist.TreeAction.Promote">
            <summary>
            Promote the node, i.e. replace its parent with it and insert its children where it was
            </summary>
        </member>
        <member name="F:Hime.Redist.TreeAction.ReplaceByEpsilon">
            <summary>
            Replace the node by epsilon
            </summary>
        </member>
        <member name="T:Hime.Redist.UnexpectedCharError">
            <summary>
            Represents an unexpected character error in the input stream of a lexer
            </summary>
        </member>
        <member name="F:Hime.Redist.UnexpectedCharError.unexpected">
            <summary>
            The unexpected character
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedCharError.Type">
            <summary>
            Gets the error's type
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedCharError.Length">
            <summary>
            Gets the error's length in the input (in number of characters)
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedCharError.Message">
            <summary>
            Gets the error's message
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedCharError.UnexpectedChar">
            <summary>
            Gets the unexpected char
            </summary>
        </member>
        <member name="M:Hime.Redist.UnexpectedCharError.#ctor(System.String,Hime.Redist.TextPosition)">
            <summary>
            Initializes this error
            </summary>
            <param name="unexpected">The errorneous character (as a string)</param>
            <param name="position">Error's position in the input</param>
        </member>
        <member name="M:Hime.Redist.UnexpectedCharError.BuildMessage">
            <summary>
            Builds the message for this error
            </summary>
            <returns>The message for this error</returns>
        </member>
        <member name="T:Hime.Redist.UnexpectedEndOfInput">
            <summary>
            Represents the unexpected of the input text while more characters were expected
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedEndOfInput.Type">
            <summary>
            Gets the error's type
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedEndOfInput.Length">
            <summary>
            Gets the error's length in the input (in number of characters)
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedEndOfInput.Message">
            <summary>
            Gets the error's message
            </summary>
        </member>
        <member name="M:Hime.Redist.UnexpectedEndOfInput.#ctor(Hime.Redist.TextPosition)">
            <summary>
            Initializes this error
            </summary>
            <param name="position">Error's position in the input</param>
        </member>
        <member name="T:Hime.Redist.UnexpectedTokenError">
            <summary>
            Represents an unexpected token error in a parser
            </summary>
        </member>
        <member name="F:Hime.Redist.UnexpectedTokenError.unexpected">
            <summary>
            The unexpected symbol
            </summary>
        </member>
        <member name="F:Hime.Redist.UnexpectedTokenError.expected">
            <summary>
            The expected terminals
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedTokenError.Type">
            <summary>
            Gets the error's type
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedTokenError.Length">
            <summary>
            Gets the error's length in the input (in number of characters)
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedTokenError.Message">
            <summary>
            Gets the error's message
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedTokenError.UnexpectedToken">
            <summary>
            Gets the unexpected token
            </summary>
        </member>
        <member name="P:Hime.Redist.UnexpectedTokenError.ExpectedTerminals">
            <summary>
            Gets the expected terminals
            </summary>
        </member>
        <member name="M:Hime.Redist.UnexpectedTokenError.#ctor(Hime.Redist.Token,Hime.Redist.Utils.ROList{Hime.Redist.Symbol})">
            <summary>
            Initializes this error
            </summary>
            <param name="token">The unexpected token</param>
            <param name="expected">The expected terminals</param>
        </member>
        <member name="M:Hime.Redist.UnexpectedTokenError.BuildMessage">
            <summary>
            Builds the message for this error
            </summary>
            <returns>The message for this error</returns>
        </member>
        <member name="T:Hime.Redist.Utils.BigList`1">
            <summary>
            Represents a list of items that is efficient in storage and addition.
            Items cannot be removed or inserted.
            </summary>
            <typeparam name="T">The type of the stored items</typeparam>
            <remarks>
            The internal representation is an array of pointers to arrays of T.
            The basic arrays of T (chunks) have a fixed size.
            </remarks>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.UPPER_SHIFT">
            <summary>
            The number of bits allocated to the lowest part of the index (within a chunk)
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.CHUNKS_SIZE">
            <summary>
            The size of the chunks
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.LOWER_MASK">
            <summary>
            Bit mask for the lowest part of the index (within a chunk)
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.INIT_CHUNK_COUNT">
            <summary>
            Initial size of the higer array (pointers to the chunks)
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.chunks">
            <summary>
            The data
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.chunkIndex">
            <summary>
            The index of the current chunk
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.BigList`1.cellIndex">
            <summary>
            The index of the next available cell within the current chunk
            </summary>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.#ctor">
            <summary>
            Initializes this list
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.BigList`1.Size">
            <summary>
            Gets the size of this list
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.BigList`1.Item(System.Int32)">
            <summary>
            Gets or sets the value of the item at the given index
            </summary>
            <param name="index">Index of an item</param>
            <returns>The value of the item at the given index</returns>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.CopyTo(System.Int32,System.Int32,`0[],System.Int32)">
            <summary>
            Copies the specified range of items to the given buffer
            </summary>
            <param name="index">The starting index of the range of items to copy</param>
            <param name="count">The size of the range of items to copy</param>
            <param name="buffer">The buffer to copy the items in</param>
            <param name="start">The starting index within the buffer to copy the items to</param>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.Add(`0)">
            <summary>
            Adds the given value at the end of this list
            </summary>
            <param name="value">The value to add</param>
            <returns>The index of the value in this list</returns>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.Add(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the given values at the end of this list
            </summary>
            <param name="values">The values to add</param>
            <param name="index">The starting index of the values to store</param>
            <param name="length">The number of values to store</param>
            <returns>The index within this list at which the values have been added</returns>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.Duplicate(System.Int32,System.Int32)">
            <summary>
            Copies the values from the given index at the end of the list
            </summary>
            <param name="from">The index to start copy from</param>
            <param name="count">The number of items to copy</param>
            <returns>The index within this list at which the values have been copied to</returns>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.Remove(System.Int32)">
            <summary>
            Removes the specified number of values from the end of this list
            </summary>
            <param name="count">The number of values to remove</param>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.DoCopy(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the given values at the end of this list
            </summary>
            <param name="values">The values to add</param>
            <param name="index">The starting index of the values to store</param>
            <param name="length">The number of values to store</param>
        </member>
        <member name="M:Hime.Redist.Utils.BigList`1.AddChunk">
            <summary>
            Adds a new (empty) chunk of cells
            </summary>
        </member>
        <member name="T:Hime.Redist.Utils.Buffer`1">
            <summary>
            Fast reusable buffer
            </summary>
            <typeparam name="T">The type of elements in this buffer</typeparam>
        </member>
        <member name="F:Hime.Redist.Utils.Buffer`1.inner">
            <summary>
            The inner data backing this buffer
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.Buffer`1.size">
            <summary>
            The number of elements in this buffer
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.Buffer`1.Size">
            <summary>
            Gets the number of elements in this buffer
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.Buffer`1.Item(System.Int32)">
            <summary>
            Gets the i-th element of this buffer
            </summary>
            <param name="index">Index within this buffer</param>
            <returns>The i-th element</returns>
        </member>
        <member name="M:Hime.Redist.Utils.Buffer`1.#ctor(System.Int32)">
            <summary>
            Initializes this buffer
            </summary>
            <param name="capacity">The initial capacity</param>
        </member>
        <member name="M:Hime.Redist.Utils.Buffer`1.Reset">
            <summary>
            Resets the content of this buffer
            </summary>
        </member>
        <member name="M:Hime.Redist.Utils.Buffer`1.Add(`0)">
            <summary>
            Adds an element to this buffer
            </summary>
            <param name="element">An element</param>
        </member>
        <member name="T:Hime.Redist.Utils.Factory`1">
            <summary>
            Represents a factory of objects for a pool
            </summary>
            <typeparam name="T">The type of the pooled objects</typeparam>
        </member>
        <member name="M:Hime.Redist.Utils.Factory`1.CreateNew(Hime.Redist.Utils.Pool{`0})">
            <summary>
            Creates a new object
            </summary>
            <param name="pool">The enclosing pool</param>
            <returns>The created object</returns>
        </member>
        <member name="T:Hime.Redist.Utils.Pool`1">
            <summary>
            Represents a pool of reusable objects
            </summary>
            <typeparam name="T">Type of the pooled objects</typeparam>
        </member>
        <member name="F:Hime.Redist.Utils.Pool`1.factory">
            <summary>
            The factory for this pool
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.Pool`1.free">
            <summary>
            Cache of the free objects in this pool
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.Pool`1.nextFree">
            <summary>
            Index of the next free object in this pool
            </summary>
        </member>
        <member name="F:Hime.Redist.Utils.Pool`1.allocated">
            <summary>
            Total number of objects in this pool
            </summary>
        </member>
        <member name="M:Hime.Redist.Utils.Pool`1.#ctor(Hime.Redist.Utils.Factory{`0},System.Int32)">
            <summary>
            Initializes the pool
            </summary>
            <param name="factory">The factory for the pooled objects</param>
            <param name="initSize">The initial size of the pool</param>
        </member>
        <member name="M:Hime.Redist.Utils.Pool`1.Acquire">
            <summary>
            Acquires an object from this pool
            </summary>
            <returns>An object from this pool</returns>
        </member>
        <member name="M:Hime.Redist.Utils.Pool`1.Return(`0)">
            <summary>
            Returns the given object to this pool
            </summary>
            <param name="obj">The returned object</param>
        </member>
        <member name="T:Hime.Redist.Utils.ROList`1">
            <summary>
            Represents a lightweight interface for a readonly list of T elements
            </summary>
            <typeparam name="T">The type of elements in this list</typeparam>
        </member>
        <member name="F:Hime.Redist.Utils.ROList`1.inner">
            <summary>
            The inner data set
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.ROList`1.Count">
            <summary>
            Gets the number of elements in this list
            </summary>
        </member>
        <member name="P:Hime.Redist.Utils.ROList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index
            </summary>
            <param name="index">An index in this list</param>
        </member>
        <member name="M:Hime.Redist.Utils.ROList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes this list
            </summary>
            <param name="original">The original items</param>
        </member>
        <member name="M:Hime.Redist.Utils.ROList`1.Contains(`0)">
            <summary>
            Determines whether this list contains the specified item
            </summary>
            <param name="item">The item to look for</param>
            <returns><c>true</c> if the item is in this list</returns>
        </member>
        <member name="M:Hime.Redist.Utils.ROList`1.IndexOf(`0)">
            <summary>
            Determines the index of the specified item in this list
            </summary>
            <param name="item">The item to look for</param>
            <returns>The index of the specified item, or -1</returns>
        </member>
        <member name="M:Hime.Redist.Utils.ROList`1.GetEnumerator">
            <summary>
            Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Hime.Redist.Utils.ROList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
    </members>
</doc>
